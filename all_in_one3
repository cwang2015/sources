      subroutine art_heat(ntotal,hsml,mass,x,vx,niac,rho,u,
     &           c,pair_i,pair_j,w,dwdx,dedt)

c----------------------------------------------------------------------
c     Subroutine to calculate the artificial heat(Fulk, 1994, p, a-17) 

c     ntotal : Number of particles                                  [in]
c     hsml   : Smoothing Length                                     [in]
c     mass   : Particle masses                                      [in]
c     x      : Coordinates of all particles                         [in]
c     vx     : Velocities of all particles                          [in]
c     rho    : Density                                              [in]
c     u      : specific internal energy                             [in]
c     c      : Sound veolcity                                       [in]
c     niac   : Number of interaction pairs                          [in]
c     pair_i : List of first partner of interaction pair            [in]
c     pair_j : List of second partner of interaction pair           [in]
c     w      : Kernel for all interaction pairs                     [in]
c     dwdx   : Derivative of kernel with respect to x, y and z      [in]
c     dedt   : produced artificial heat, adding to energy Eq.      [out]

      use param
      implicit none
      
      integer ntotal,niac,pair_i(max_interaction),
     &        pair_j(max_interaction)
      double precision hsml(maxn), mass(maxn), x(dim,maxn),vx(dim,maxn),
     &                 rho(maxn), u(maxn), c(maxn),w(max_interaction),
     &                 dwdx(dim,max_interaction), dedt(maxn)
      integer i,j,k,d
      double precision dx, dvx(dim), vr, rr, h, mc, mrho, mhsml, 
     &                 vcc(maxn), hvcc, mui, muj, muij, rdwdx, g1,g2
      
c---  Parameter for the artificial heat conduction:
     
      g1=0.1
      g2=1.0      
      do i=1,ntotal
        vcc(i) = 0.e0         
        dedt(i) = 0.e0
      enddo
    
      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        do d=1,dim
          dvx(d) = vx(d,j) - vx(d,i) 
        enddo        
        hvcc = dvx(1)*dwdx(1,k)
        do d=2,dim
          hvcc = hvcc + dvx(d)*dwdx(d,k)
        enddo    
         vcc(i) = vcc(i) + mass(j)*hvcc/rho(j)
         vcc(j) = vcc(j) + mass(i)*hvcc/rho(i)
      enddo  
   
      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        mhsml= (hsml(i)+hsml(j))/2.
        mrho = 0.5e0*(rho(i) + rho(j))                          
        rr = 0.e0
        rdwdx = 0.e0
        do d=1,dim
          dx = x(d,i) -  x(d,j)
          rr = rr + dx*dx
          rdwdx  = rdwdx + dx*dwdx(d,k)            
        enddo             
        mui=g1*hsml(i)*c(i) + g2*hsml(i)**2*(abs(vcc(i))-vcc(i))
        muj=g1*hsml(j)*c(j) + g2*hsml(j)**2*(abs(vcc(j))-vcc(j))
        muij= 0.5*(mui+muj)     
        h = muij/(mrho*(rr+0.01*mhsml**2))*rdwdx
        dedt(i) = dedt(i) + mass(j)*h*(u(i)-u(j))
        dedt(j) = dedt(j) + mass(i)*h*(u(j)-u(i))
      enddo

      do i=1,ntotal
        dedt(i) = 2.0e0*dedt(i)          
      enddo

      return
      end subroutine
      subroutine art_visc(parts)

c----------------------------------------------------------------------
c     Subroutine to calculate the artificial viscosity (Monaghan, 1992) 

c     ntotal : Number of particles (including virtual particles)    [in]
c     hsml   : Smoothing Length                                     [in]
c     mass   : Particle masses                                      [in]
c     x      : Coordinates of all particles                         [in]
c     vx     : Velocities of all particles                          [in]
c     niac   : Number of interaction pairs                          [in]
c     rho    : Density                                              [in]
c     c      : Temperature                                          [in]
c     pair_i : List of first partner of interaction pair            [in]
c     pair_j : List of second partner of interaction pair           [in]
c     w      : Kernel for all interaction pairs                     [in]
c     dwdx   : Derivative of kernel with respect to x, y and z      [in]
c     dvxdt  : Acceleration with respect to x, y and z             [out] 
c     dedt   : Change of specific internal energy                  [out]
 
      use param
      use m_particles
      implicit none

      type(particles) parts

      integer ntotal, niac
      integer, pointer, dimension(:) :: pair_i, pair_j      
      double precision, pointer, dimension(:) :: hsml, mass, rho, c
      double precision, pointer, dimension(:,:) :: x, dwdx, vx
      double precision, pointer, dimension(:) :: dedt, dvxdt(:,:)
      double precision dx, dvx(dim), alpha, beta, etq, piv,
     &       muv, vr, rr, h, mc, mrho, mhsml
      integer i,j,k,d

c     Parameter for the artificial viscosity:
c     Shear viscosity
!      parameter( alpha = 1.e0   )
     
c     Bulk viscosity
!      parameter( beta  = 1.e0  ) 
      
c     Parameter to avoid singularities
      parameter( etq   = 0.1e0 )

      ntotal   =  parts%ntotal + parts%nvirt
      niac     =  parts%niac
            
      pair_i   => parts%pair_i
      pair_j   => parts%pair_j
      hsml     => parts%hsml
      mass     => parts%mass
      x        => parts%x
      dwdx     => parts%dwdx
      vx       => parts%vx
      rho      => parts%rho
      c        => parts%c
      dvxdt    => parts%dvx
      dedt     => parts%du

      if(trim(parts%imaterial)=='water')then
         alpha = 0.01; beta = 1.0
      elseif(trim(parts%imaterial)=='soil')then
         alpha = 1.0;  beta = 1.0
      endif
          
c     Calculate SPH sum for artificial viscosity
      
      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        mhsml= (hsml(i)+hsml(j))/2.
        vr = 0.e0
        rr = 0.e0
        do d=1,dim
          dvx(d) = vx(d,i) - vx(d,j)
          dx     =  x(d,i) -  x(d,j)
          vr     = vr + dvx(d)*dx
          rr     = rr + dx*dx
        enddo

c     Artificial viscous force only if v_ij * r_ij < 0

        if (vr.lt.0.e0) then

c     Calculate muv_ij = hsml v_ij * r_ij / ( r_ij^2 + hsml^2 etq^2 )
            
          muv = mhsml*vr/(rr + mhsml*mhsml*etq*etq)
          
c     Calculate PIv_ij = (-alpha muv_ij c_ij + beta muv_ij^2) / rho_ij

          mc   = 0.5e0*(c(i) + c(j))
          mrho = 0.5e0*(rho(i) + rho(j))
          piv  = (beta*muv - alpha*mc)*muv/mrho              

c     Calculate SPH sum for artificial viscous force

          do d=1,dim
            h = -piv*dwdx(d,k)
            dvxdt(d,i) = dvxdt(d,i) + mass(j)*h
            dvxdt(d,j) = dvxdt(d,j) - mass(i)*h
!            dedt(i) = dedt(i) - mass(j)*dvx(d)*h
!            dedt(j) = dedt(j) - mass(i)*dvx(d)*h
          enddo
        endif
      enddo

c     Change of specific internal energy:

!      do i=1,ntotal
!         dedt(i) = 0.5e0*dedt(i)  !!! Problematic when accumulated!      
!      enddo

      return
      end subroutine

!-------------------------------------------------------------------
      subroutine art_density(parts)
!-------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts

      integer ntotal, niac
      integer, pointer, dimension(:) :: pair_i, pair_j      
      double precision, pointer, dimension(:) :: hsml, mass, rho, c
      double precision, pointer, dimension(:,:) :: x, dwdx, vx, drhodx
      double precision, pointer, dimension(:) :: dedt, drho(:)
      double precision dx(dim), dvx(dim), alpha, beta, etq, piv, delta,
     &       muv, vr, rr, h, mc, mrho, mhsml
      integer i,j,k,d

c     Parameter 
!      parameter( delta   = 0.1d0 )

c      write(*,*) 'In art_density...'

      ntotal   =  parts%ntotal + parts%nvirt
      niac     =  parts%niac
            
      pair_i   => parts%pair_i
      pair_j   => parts%pair_j
      hsml     => parts%hsml
      mass     => parts%mass
      x        => parts%x
      dwdx     => parts%dwdx
      vx       => parts%vx
      rho      => parts%rho
      c        => parts%c
      drho     => parts%drho
      drhodx   => parts%drhodx

      if(trim(parts%imaterial)=='water')then
         delta = 0.1d0
      elseif(trim(parts%imaterial)=='soil')then
         delta = 0.1d0
      endif
          
      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        rr = 0.e0
        do d=1,dim
          dx(d)     =  x(d,i) -  x(d,j)
          rr     = rr + dx(d)*dx(d)
        enddo
            
        muv = 2.0*(rho(i)-rho(j))/rr

        h = 0.d0
        do d=1,dim
           h = h + (dx(d)*muv - (drhodx(d,i)+drhodx(d,j)))*dwdx(d,k)
        enddo
        drho(i) = drho(i) + delta*hsml(i)*c(i)*mass(j)*h/rho(j)
        drho(j) = drho(j) - delta*hsml(j)*c(j)*mass(i)*h/rho(i)
        
      enddo

      return
      end subroutine


!-----------------------------------------------------------------
      subroutine renormalize_density_gradient(parts)
!-----------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts

      integer ntotal, niac
      integer, pointer, dimension(:) :: pair_i, pair_j      
      double precision, pointer, dimension(:) :: mass, rho
      double precision, pointer, dimension(:,:) :: x, dwdx
      double precision, pointer, dimension(:) :: drhodx,drhody

      double precision, dimension(maxn) :: L11,L12,L21,L22
      double precision dx(dim), drho, tmp, La, h
      integer i,j,k,d

      ntotal   =  parts%ntotal + parts%nvirt
      niac     =  parts%niac
            
      pair_i   => parts%pair_i
      pair_j   => parts%pair_j
      mass     => parts%mass
      x        => parts%x
      dwdx     => parts%dwdx
      rho      => parts%rho
      drhodx   => parts%drhodx(1,:)
      drhody   => parts%drhodx(2,:)

      L11 = 0.d0; L12 = 0.d0; L21 = 0.d0; L22 = 0.d0

c Calculate La

      do k = 1, niac
         i = pair_i(k)
         j = pair_j(k)
         do d = 1, dim
            dx(d) = x(d,j)-x(d,i)
         enddo
         L11(i) = L11(i) + dx(1)*dwdx(1,k)*mass(j)/rho(j)
         L12(i) = L12(i) + dx(1)*dwdx(2,k)*mass(j)/rho(j)
         L21(i) = L21(i) + dx(2)*dwdx(1,k)*mass(j)/rho(j)
         L22(i) = L22(i) + dx(2)*dwdx(2,k)*mass(j)/rho(j)

         L11(j) = L11(j) + dx(1)*dwdx(1,k)*mass(i)/rho(i)
         L12(j) = L12(j) + dx(1)*dwdx(2,k)*mass(i)/rho(i)
         L21(j) = L21(j) + dx(2)*dwdx(1,k)*mass(i)/rho(i)
         L22(j) = L22(j) + dx(2)*dwdx(2,k)*mass(i)/rho(i)
      enddo

c Calculate inverse(La)

      do i = 1, ntotal
         La   = L11(i)*L22(i)-L21(i)*L12(i)
         if(La<1.e-7) stop 'renormalize failed!'
         tmp  = L11(i)
         L11(i) = L22(i)/La
         L22(i) = tmp/La

         L12(i) = -L12(i)/La
         L21(i) = -L21(i)/La
      enddo

c Calculate Grad(rho)
 
      drhodx = 0.d0; drhody = 0.d0

      do k = 1, niac
         i = pair_i(k)
         j = pair_j(k)
         drho = rho(j)-rho(i)
         h = drho*(L11(i)*dwdx(1,k)+L12(i)*dwdx(2,k))
         drhodx(i) = drhodx(i)+h*mass(j)/rho(j)
         h = drho*(L21(i)*dwdx(1,k)+L22(i)*dwdx(2,k))
         drhody(i) = drhody(i)+h*mass(j)/rho(j)

         h = drho*(L11(j)*dwdx(1,k)+L12(j)*dwdx(2,k))
         drhodx(j) = drhodx(j)+h*mass(i)/rho(i)
         h = drho*(L21(j)*dwdx(1,k)+L22(j)*dwdx(2,k))
         drhody(j) = drhody(j)+h*mass(i)/rho(i)
      enddo

      return
      end subroutine

!-------------------------------------------------------------------
      subroutine art_volume_fraction_water2(water)
!-------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) water, soil

      double precision dx(dim), delta, muv, rr, h
      integer i,j,k,d

c     Parameter 
      parameter( delta   = 0.1d0 )

      do k=1,water%niac
        i = water%pair_i(k)
        j = water%pair_j(k)
        rr = 0.e0
        do d=1,dim
          dx(d)     =  water%x(d,i) - water%x(d,j)
          rr     = rr + dx(d)*dx(d)
        enddo
            
        muv = 2.0*(water%vof(i)-water%vof(j))/rr

        h = 0.d0
        do d=1,dim
           h = h + dx(d)*muv*water%dwdx(d,k)
        enddo
        water%dvof(i) = water%dvof(i) + delta*water%hsml(i)*water%c(i)*
     &                  water%mass(j)*h/water%rho(j)
        water%dvof(j) = water%dvof(j) - delta*water%hsml(j)*water%c(j)*
     &                  water%mass(i)*h/water%rho(i)
      enddo

      return
      end subroutine

!-------------------------------------------------------------------
      subroutine art_stress(soil)
!-------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) water, soil

      double precision dx(dim), delta, muv, rr, h
      integer i,j,k,d

c     Parameter 
      parameter( delta   = 0.1d0 )

      do k=1,soil%niac
        i = soil%pair_i(k)
        j = soil%pair_j(k)
        rr = 0.e0
        do d=1,dim
          dx(d)     =  soil%x(d,i) - soil%x(d,j)
          rr     = rr + dx(d)*dx(d)
        enddo
            
        muv = 2.0*(soil%p(i)-soil%p(j))/rr

        h = 0.d0
        do d=1,dim
           h = h + dx(d)*muv*soil%dwdx(d,k)
        enddo

        soil%dp(i) = soil%dp(i) + delta*soil%hsml(i)*soil%c(i)*
     &                  soil%mass(j)*h/soil%rho(j)
        soil%dp(j) = soil%dp(j) - delta*soil%hsml(j)*soil%c(j)*
     &                  soil%mass(i)*h/soil%rho(i)

        muv = 2.0*(soil%sxx(i)-soil%sxx(j))/rr

        h = 0.d0
        do d=1,dim
           h = h + dx(d)*muv*soil%dwdx(d,k)
        enddo

        soil%dsxx(i) = soil%dsxx(i) + delta*soil%hsml(i)*soil%c(i)*
     &                  soil%mass(j)*h/soil%rho(j)
        soil%dsxx(j) = soil%dsxx(j) - delta*soil%hsml(j)*soil%c(j)*
     &                  soil%mass(i)*h/soil%rho(i)

        muv = 2.0*(soil%sxy(i)-soil%sxy(j))/rr

        h = 0.d0
        do d=1,dim
           h = h + dx(d)*muv*soil%dwdx(d,k)
        enddo

        soil%dsxy(i) = soil%dsxy(i) + delta*soil%hsml(i)*soil%c(i)*
     &                  soil%mass(j)*h/soil%rho(j)
        soil%dsxy(j) = soil%dsxy(j) - delta*soil%hsml(j)*soil%c(j)*
     &                  soil%mass(i)*h/soil%rho(i)

        muv = 2.0*(soil%syy(i)-soil%syy(j))/rr

        h = 0.d0
        do d=1,dim
           h = h + dx(d)*muv*soil%dwdx(d,k)
        enddo

        soil%dsyy(i) = soil%dsyy(i) + delta*soil%hsml(i)*soil%c(i)*
     &                  soil%mass(j)*h/soil%rho(j)
        soil%dsyy(j) = soil%dsyy(j) - delta*soil%hsml(j)*soil%c(j)*
     &                  soil%mass(i)*h/soil%rho(i)

      enddo

      return
      end subroutine

!--------------------------------------------------------------------
      subroutine tension_instability(water)
!--------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) water
      double precision, pointer, dimension(:) :: mass, hsml, rho, p, w
      double precision, pointer, dimension(:,:) :: dvx,dwdx
      integer, pointer, dimension(:) :: pair_i, pair_j
      double precision wi,dx(2),dwx(2),n,fij,eps, pa, pb
      integer i,j,k,d, niac

!      write(*,*) 'In tension_instability...'

      niac = water%niac

      pair_i => water%pair_i
      pair_j => water%pair_j
      mass => water%mass
      rho  => water%rho
      hsml => water%hsml
      p    => water%p
      dwdx => water%dwdx
      dvx  => water%dvx
      w    => water%w

      n = 2.55
      eps = 0.1
      call kernel(hsml(1),dx,hsml(1),wi,dwx)

      do k = 1, niac
         i = pair_i(k)
         j = pair_j(k)
         pa = 0.d0
         pb = 0.d0
         if(p(i)<0) pa = abs(p(i))
         if(p(j)<0) pb = abs(p(j)) 

         fij = (w(k)/wi)**n*(-eps)*
     &         (pa/rho(i)**2+pb/rho(j)**2)

         do d = 1, dim
            dvx(d,i) = dvx(d,i)+fij*mass(j)*dwdx(d,k)
            dvx(d,j) = dvx(d,j)-fij*mass(i)*dwdx(d,k)
         enddo
      enddo

      return
      end subroutine




      subroutine av_vel(parts)

c----------------------------------------------------------------------
c     Subroutine to calculate the average velocity to correct velocity
c     for preventing.penetration (monaghan, 1992)

c     ntotal : Number of particles                                  [in]
c     mass   : Particle masses                                      [in]
c     niac   : Number of interaction pairs                          [in]
c     pair_i : List of first partner of interaction pair            [in]
c     pair_j : List of second partner of interaction pair           [in]
c     w      : Kernel for all interaction pairs                     [in]
c     vx     : Velocity of each particle                            [in]
c     rho    : Density of each particle                             [in]
c     av     : Average velocityof each particle                    [out]
   
      use param 
      use m_particles
      implicit none

      type(particles) parts

      integer ntotal, niac
      integer, pointer, dimension(:) :: pair_i, pair_j
      double precision, pointer, dimension(:) :: mass, w, rho
      double precision, pointer, dimension(:,:) :: vx, av

      double precision   vcc, dvx(dim), epsilon
      integer i,j,k,d       

      ntotal = parts%ntotal
      niac   = parts%niac

      pair_i => parts%pair_i
      pair_j => parts%pair_j
      mass   => parts%mass
      w      => parts%w
      vx     => parts%vx
      rho    => parts%rho
      av     => parts%av
      
c     epsilon --- a small constants chosen by experence, may lead to instability.
c     for example, for the 1 dimensional shock tube problem, the E <= 0.3

      epsilon = 0.01 !0.3
      
!      do i = 1, ntotal
!        do d = 1, dim
!          av(d,i) = 0.
!        enddo 
!      enddo

      av = 0.d0
     
      do k=1,niac       
         i = pair_i(k)
         j = pair_j(k)       
         do d=1,dim
            dvx(d) = vx(d,i) - vx(d,j)            
            av(d, i) = av(d,i) - 2*mass(j)*dvx(d)/(rho(i)+rho(j))*w(k)
            av(d, j) = av(d,j) + 2*mass(i)*dvx(d)/(rho(i)+rho(j))*w(k)                      
         enddo                    
      enddo  
        
      do i = 1, ntotal
         do d = 1, dim
            av(d,i) = epsilon * av(d,i)
         enddo 
      enddo             

      return
      end subroutine
      subroutine sum_density(parts) 

C----------------------------------------------------------------------
C   Subroutine to calculate the density with SPH summation algorithm.

C     ntotal : Number of particles                                  [in]
C     hsml   : Smoothing Length                                     [in]
C     mass   : Particle masses                                      [in]
C     niac   : Number of interaction pairs                          [in]
C     pair_i : List of first partner of interaction pair            [in]
C     pair_j : List of second partner of interaction pair           [in]
C     w      : Kernel for all interaction pairs                     [in]
c     itype   : type of particles                                   [in]
c     x       : Coordinates of all particles                        [in]
c     rho    : Density                                             [out]
   
      use param 
      use m_particles
      implicit none

      type(particles) parts

      integer ntotal, niac
      integer, pointer, dimension(:) :: pair_i, pair_j, itype 
      double precision, pointer, dimension(:) :: hsml, mass, w, rho
 
      integer i, j, k, d      
      double precision selfdens, hv(dim), r, wi(maxn)     

      ntotal = parts%ntotal + parts%nvirt
      niac   = parts%niac
      pair_i =>parts%pair_i
      pair_j =>parts%pair_j
      itype  =>parts%itype
      hsml   =>parts%hsml
      mass   =>parts%mass
      w      =>parts%w
      rho    =>parts%rho

c     wi(maxn)---integration of the kernel itself
        
      do d=1,dim
        hv(d) = 0.e0
      enddo

c     Self density of each particle: Wii (Kernel for distance 0)
c     and take contribution of particle itself:

      r=0.
      
c     Firstly calculate the integration of the kernel over the space

      do i=1,ntotal
        call kernel(r,hv,hsml(i),selfdens,hv)
        wi(i)=selfdens*mass(i)/rho(i)
      enddo

      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        wi(i) = wi(i) + mass(j)/rho(j)*w(k)
        wi(j) = wi(j) + mass(i)/rho(i)*w(k)
      enddo

c     Secondly calculate the rho integration over the space

      do i=1,ntotal
        call kernel(r,hv,hsml(i),selfdens,hv)
        rho(i) = selfdens*mass(i)
      enddo

c     Calculate SPH sum for rho:
      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        rho(i) = rho(i) + mass(j)*w(k)
        rho(j) = rho(j) + mass(i)*w(k)
      enddo

c     Thirdly, calculate the normalized rho, rho=sum(rho)/sum(w)
      if (nor_density) then 
        do i=1, ntotal
          rho(i)=rho(i)/wi(i)
        enddo
      endif 
 
      end
      
      subroutine con_density(parts)

c----------------------------------------------------------------------
c     Subroutine to calculate the density with SPH continuiity approach.

c     ntotal : Number of particles                                  [in]
c     mass   : Particle masses                                      [in]
c     niac   : Number of interaction pairs                          [in]
c     pair_i : List of first partner of interaction pair            [in]
c     pair_j : List of second partner of interaction pair           [in]
c     dwdx   : derivation of Kernel for all interaction pairs       [in]
c     vx     : Velocities of all particles                          [in]
c     itype   : type of particles                                   [in]
c     x      : Coordinates of all particles                         [in]
c     rho    : Density                                              [in]
c     drhodt : Density change rate of each particle                [out]   

      use param
      use m_particles 
      implicit none
  
      type(particles) parts      

      integer ntotal,niac
      integer, pointer, dimension(:) :: pair_i, pair_j, itype    
      double precision, pointer, dimension(:) :: mass, rho, drhodt
      double precision, pointer, dimension(:,:) :: x, dwdx, vx
      integer i,j,k,d    
      double precision vcc, dvx(dim) 
      
      ntotal = parts%ntotal + parts%nvirt
      niac   = parts%niac
      pair_i => parts%pair_i
      pair_j => parts%pair_j
      itype  => parts%itype
      x      => parts%x
      mass   => parts%mass
      dwdx   => parts%dwdx
      vx     => parts%vx
      rho    => parts%rho
      drhodt => parts%drho

      do i = 1, ntotal
        drhodt(i) = 0.
      enddo
     
      do k=1,niac      
        i = pair_i(k)
        j = pair_j(k)
        do d=1,dim
          dvx(d) = vx(d,i) - vx(d,j) 
        enddo        
        vcc = dvx(1)*dwdx(1,k)        
        do d=2,dim
          vcc = vcc + dvx(d)*dwdx(d,k)
        enddo    
        drhodt(i) = drhodt(i) + mass(j)*vcc
        drhodt(j) = drhodt(j) + mass(i)*vcc       
      enddo    

      end
       subroutine direct_find(parts)

c----------------------------------------------------------------------
c   Subroutine to calculate the smoothing funciton for each particle and
c   the interaction parameters used by the SPH algorithm. Interaction 
c   pairs are determined by directly comparing the particle distance 
c   with the corresponding smoothing length.

c     itimestep : Current time step                                 [in]
c     ntotal    : Number of particles                               [in]
c     hsml      : Smoothing Length                                  [in]
c     x         : Coordinates of all particles                      [in]
c     niac      : Number of interaction pairs                      [out]
c     pair_i    : List of first partner of interaction pair        [out]
c     pair_j    : List of second partner of interaction pair       [out]
c     w         : Kernel for all interaction pairs                 [out]
c     dwdx      : Derivative of kernel with respect to x, y and z  [out]
c     countiac  : Number of neighboring particles                  [out]

      use param
      use m_particles
      implicit none
      
      type(particles), target :: parts

      integer ntotal, niac,i,j,d
      integer, pointer, dimension(:) :: pair_i, pair_j, countiac
      double precision, pointer, dimension(:) :: hsml, w
      double precision, pointer, dimension(:,:) :: x, dwdx
      double precision dxiac(dim), driac, r, mhsml, tdwdx(dim)
      integer  sumiac, maxiac, miniac, noiac, maxp, minp, scale_k 
      logical :: dbg = .false.

      if(dbg) write(*,*) 'In direct_find...'

      ntotal   =   parts%ntotal + parts%nvirt
      pair_i   =>  parts%pair_i
      pair_j   =>  parts%pair_j
      countiac =>  parts%countiac
      hsml     =>  parts%hsml
      x        =>  parts%x
      w        =>  parts%w
      dwdx     =>  parts%dwdx

      if (skf.eq.1) then 
        scale_k = 2 
      else if (skf.eq.2) then 
        scale_k = 3 
      else if (skf.eq.3) then 
        scale_k = 3 
      endif 
     
      do i=1,ntotal
        countiac(i) = 0
      enddo

      niac = 0

      do i=1,ntotal-1     
        do j = i+1, ntotal
          dxiac(1) = x(1,i) - x(1,j)
          driac    = dxiac(1)*dxiac(1)
          do d=2,dim
            dxiac(d) = x(d,i) - x(d,j)
            driac    = driac + dxiac(d)*dxiac(d)
          enddo
          mhsml = (hsml(i)+hsml(j))/2.
          if (sqrt(driac).lt.scale_k*mhsml) then
            if (niac.lt.max_interaction) then    

c     Neighboring pair list, and totalinteraction number and
c     the interaction number for each particle 

              niac = niac + 1
              pair_i(niac) = i
              pair_j(niac) = j
              r = sqrt(driac)
              countiac(i) = countiac(i) + 1
              countiac(j) = countiac(j) + 1

c     Kernel and derivations of kernel
              call kernel(r,dxiac,mhsml,w(niac),tdwdx)
              do d=1,dim
                dwdx(d,niac) = tdwdx(d)
              enddo                                      
            else
              print *,
     &        ' >>> ERROR <<< : Too many interactions' 
              stop
            endif
          endif
        enddo
      enddo  

c     Statistics for the interaction

      sumiac = 0
      maxiac = 0
      miniac = 1000
      noiac  = 0
      do i=1,ntotal
        sumiac = sumiac + countiac(i)
        if (countiac(i).gt.maxiac) then
          maxiac = countiac(i)
          maxp = i
        endif
        if (countiac(i).lt.miniac) then 
           miniac = countiac(i)
           minp = i
        endif
        if (countiac(i).eq.0)      noiac  = noiac + 1
      enddo

      parts%niac = niac
      parts%maxp = maxp;        parts%minp = minp  
      parts%maxiac = maxiac;    parts%miniac = miniac
      parts%sumiac = sumiac;    parts%noiac = noiac
 
      end subroutine

       subroutine direct_find_2(parts,part2)

c----------------------------------------------------------------------
c   Subroutine to calculate the smoothing funciton for each particle and
c   the interaction parameters used by the SPH algorithm. Interaction 
c   pairs are determined by directly comparing the particle distance 
c   with the corresponding smoothing length.

c     itimestep : Current time step                                 [in]
c     ntotal    : Number of particles                               [in]
c     hsml      : Smoothing Length                                  [in]
c     x         : Coordinates of all particles                      [in]
c     niac      : Number of interaction pairs                      [out]
c     pair_i    : List of first partner of interaction pair        [out]
c     pair_j    : List of second partner of interaction pair       [out]
c     w         : Kernel for all interaction pairs                 [out]
c     dwdx      : Derivative of kernel with respect to x, y and z  [out]
c     countiac  : Number of neighboring particles                  [out]

      use param
      use m_particles
      implicit none
      
      type(particles), target :: parts, part2

      integer ntotal, niac,i,j,d
      integer, pointer, dimension(:) :: pair_i, pair_j, countiac
      double precision, pointer, dimension(:) :: hsml, w
      double precision, pointer, dimension(:,:) :: x, dwdx
      double precision dxiac(dim), driac, r, mhsml, tdwdx(dim)
      integer  sumiac, maxiac, miniac, noiac, maxp, minp, scale_k 
      logical :: dbg = .false.

      if(dbg) write(*,*) 'In direct_find...'

      ntotal   =   parts%ntotal + parts%nvirt
      pair_i   =>  parts%pair_i
      pair_j   =>  parts%pair_j
      countiac =>  parts%countiac
      hsml     =>  parts%hsml
      x        =>  parts%x
      w        =>  parts%w
      dwdx     =>  parts%dwdx

      if (skf.eq.1) then 
        scale_k = 2 
      else if (skf.eq.2) then 
        scale_k = 3 
      else if (skf.eq.3) then 
        scale_k = 3 
      endif 
     
      do i=1,ntotal
        countiac(i) = 0
      enddo
      part2%countiac = 0

      niac = 0

      do i=1,ntotal     
        do j = 1, part2%ntotal+part2%nvirt
          dxiac(1) = x(1,i) - part2%x(1,j)
          driac    = dxiac(1)*dxiac(1)
          do d=2,dim
            dxiac(d) = x(d,i) - part2%x(d,j)
            driac    = driac + dxiac(d)*dxiac(d)
          enddo
          mhsml = (hsml(i)+part2%hsml(j))/2.
          if (sqrt(driac).lt.scale_k*mhsml) then
            if (niac.lt.max_interaction) then    

c     Neighboring pair list, and totalinteraction number and
c     the interaction number for each particle 

              niac = niac + 1
              pair_i(niac) = i
              pair_j(niac) = j
              r = sqrt(driac)
              countiac(i) = countiac(i) + 1
              part2%countiac(j) = part2%countiac(j) + 1

c     Kernel and derivations of kernel
              call kernel(r,dxiac,mhsml,w(niac),tdwdx)
              do d=1,dim
                dwdx(d,niac) = tdwdx(d)
              enddo                                  	     
            else
              print *,
     &        ' >>> ERROR <<< : Too many interactions' 
              stop
            endif
          endif
        enddo
      enddo  

c     Statistics for the interaction

      sumiac = 0
      maxiac = 0
      miniac = 1000
      noiac  = 0
      do i=1,ntotal
        sumiac = sumiac + countiac(i)
        if (countiac(i).gt.maxiac) then
	  maxiac = countiac(i)
	  maxp = i
	endif
	if (countiac(i).lt.miniac) then 
	  miniac = countiac(i)
          minp = i
	endif
        if (countiac(i).eq.0)      noiac  = noiac + 1
      enddo

      parts%niac = niac
      parts%maxp = maxp;        parts%minp = minp  
      parts%maxiac = maxiac;    parts%miniac = miniac
      parts%sumiac = sumiac;    parts%noiac = noiac
 
c   Statistics for the interaction of part2 is omitted!!!

      end subroutine
      subroutine p_gas(rho, u, p, c)
      
c----------------------------------------------------------------------
c   Gamma law EOS: subroutine to calculate the pressure and sound  
 
c     rho    : Density                                              [in]
c     u      : Internal energy                                      [in]
c     p      : Pressure                                            [out]
c     c      : sound velocity                                      [out]
          
      implicit none
      double precision rho, u, p, c   
      double precision gamma 
          
c      For air (idea gas)

      gamma=1.4
      p = (gamma-1) * rho * u     
      c = sqrt((gamma-1) * u) 
     
      end         
      
      subroutine p_art_water(rho, p, c)
      
c----------------------------------------------------------------------
c   Artificial equation of state for the artificial compressibility 

c     rho    : Density                                              [in]
c     u      : Internal energy                                      [in]
c     p      : Pressure                                            [out]
c     c      : sound velocity                                      [out]
c     Equation of state for artificial compressibility   

      implicit none
      double precision rho, u, p, c
      double precision gamma, rho0, b

c     Artificial EOS, Form 1 (Monaghan, 1994)
      gamma=7.
      rho0=1000.       
      b = 14290 ! 1.013e5
      p = b*((rho/rho0)**gamma-1)      
c      c = 1480.
      c = 10

c     Artificial EOS, Form 2 (Morris, 1997)
c      c = 0.01
c      p = c**2 * rho      
      
      end

      function rho_initial(p)
c---------------------------------------------------------------------
      implicit none
      double precision rho_initial, p
      double precision gamma, rho0, b

      gamma = 7.
      rho0=1000.  !*0.3
      b = 14290 !1.013e5

      rho_initial = rho0*(p/b+1)**(1/gamma)
 
      return
      end function

c------------------------For soil--------------------------------------

      subroutine p_art_soil(rho, p)
c----------------------------------------------------------------------
      implicit none
      double precision rho, u, p, c
      double precision k, rho0, b,pmax,g,hmax

      rho0=2560.
      g = -9.8
      hmax = -0.6
      pmax = rho0*g*hmax
      k = 10*pmax       

      p = k*((rho/rho0)-1)      
      
      return
      end subroutine

      function rho_soil_initial(p)      
c----------------------------------------------------------------------
      implicit none
      double precision rho, u, p, c
      double precision k, rho0, b, pmax, g, hmax, rho_soil_initial

      rho0=2560.   !*0.7
      g = -9.8
      hmax = -0.6

      pmax = rho0*g*hmax

      k = 10*pmax       
      rho_soil_initial = rho0*(p/k+1)      
      
      return
      end function

      subroutine initial_density(parts)
c---------------------------------------------------------------------
      use m_particles
      implicit none

      type(particles) parts
      type(material), pointer :: water, soil
      integer ntotal
      
      ntotal = parts%ntotal+parts%nvirt

      if(parts%imaterial=='water')then

         water => parts%material
         parts%rho(1:ntotal) = water%rho0*(parts%p(1:ntotal)/water%b+1)
     &                       **(1/water%gamma)

      elseif(parts%imaterial=='soil')then

         soil => parts%material
         !parts%rho(1:ntotal) = soil%rho0*(parts%p(1:ntotal)/soil%k+1)

      endif
 
      return
      end subroutine

c ---------------------------------------------------------------------
                      subroutine pressure(parts)
c----------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts
      type(material), pointer :: water, soil
      integer ntotal, i
      
      ntotal = parts%ntotal+parts%nvirt

      if(parts%imaterial=='water')then

         water => parts%material
         parts%p(1:ntotal) = water%b*((parts%rho(1:ntotal)/(water%rho0
     &                       *parts%vof(1:ntotal)))    !!! False density
     &                     **water%gamma-1)

! Tension instability
!                              if(water_tension_instability)then
!         do i = 1, ntotal
!            if(parts%p(i)<0) parts%p(i) = 0.d0
!         enddo
!                              endif

         parts%c(1:ntotal) = water%c         

      elseif(parts%imaterial=='soil')then

         soil => parts%material
!         parts%p(1:ntotal) = soil%k*(parts%rho(1:ntotal)/soil%rho0-1)
!         parts%p(1:ntotal) = parts%p(1:ntotal)
!     &                      -soil%k*parts%vcc(1:ntotal)*0.000005   !*dt
         parts%c(1:ntotal) = soil%c

      endif

      return      
      end subroutine
    
      subroutine ext_force(parts)

c--------------------------------------------------------------------------
c     Subroutine to calculate the external forces, e.g. gravitational forces.      
c     The forces from the interactions with boundary virtual particles 
c     are also calculated here as external forces.

c     here as the external force. 
c     ntotal  : Number of particles                                 [in]
c     mass    : Particle masses                                     [in]
c     x       : Coordinates of all particles                        [in]
c     pair_i : List of first partner of interaction pair            [in]
c     pair_j : List of second partner of interaction pair           [in]
c     itype   : type of particles                                   [in]
c     hsml   : Smoothing Length                                     [in]
c     dvxdt   : Acceleration with respect to x, y and z            [out] 

      use param
      use m_particles
      implicit none

      type(particles) parts

      integer ntotal, niac
      integer, pointer, dimension(:) :: pair_i, pair_j, itype
      double precision, pointer, dimension(:) :: mass, hsml, x(:,:)
      double precision, pointer, dimension(:,:) :: dvxdt
          
      double precision dx(dim), rr, f, rr0, dd, p1, p2     
      integer i, j, k, d

      ntotal = parts%ntotal + parts%nvirt
      niac   = parts%niac

      pair_i   => parts%pair_i
      pair_j   => parts%pair_j
      itype    => parts%itype
      mass     => parts%mass
      x        => parts%x
      hsml     => parts%hsml
      dvxdt    => parts%dvx
           
c     Consider self-gravity or not ?

      if (self_gravity) then
        do i = 1, ntotal
          dvxdt(dim, i) = dvxdt(dim,i)-9.8
        enddo
      endif 
      
c     Boundary particle force and penalty anti-penetration force. 
!      rr0 =0.02  !1.25e-5
!      rr0 = 0.005
      rr0 = hsml(1)
      dd = 1.e-2
      p1 = 12
      p2 = 4
      
      do  k=1,niac
        i = pair_i(k)
        j = pair_j(k)  
        if(itype(i).gt.0.and.itype(j).lt.0) then  
          rr = 0.      
          do d=1,dim
            dx(d) =  x(d,i) -  x(d,j)
            rr = rr + dx(d)*dx(d)
          enddo  
          rr = sqrt(rr)
          if(rr.lt.rr0) then
            f = ((rr0/rr)**p1-(rr0/rr)**p2)/rr**2
            do d = 1, dim
              dvxdt(d, i) = dvxdt(d, i) + dd*dx(d)*f
            enddo
          endif
        endif        
      enddo   
       
      end         
      subroutine grid_geom(i,x,ngridx,maxgridx,mingridx,dgeomx,xgcell)

c----------------------------------------------------------------------
c   Subroutine to calculate the coordinates (xgcell) of the cell of 
c   the sorting  grid, in which the particle with coordinates (x) lies.

c     x        : Coordinates of particle                            [in]    
c     ngridx   : Number of sorting grid cells in x, y, z-direction  [in]
c     maxgridx : Maximum x-, y- and z-coordinate of grid range      [in]
c     mingridx : Minimum x-, y- and z-coordinate of grid range      [in]
c     dgeomx   : x-, y- and z-expansion of grid range               [in]
c     xgcell   : x-, y- and z-coordinte of sorting grid cell       [out]

      use param
      implicit none
C      include 'param.inc'

      integer i, ngridx(dim),xgcell(3)
      double precision x(dim), maxgridx(dim), mingridx(dim), dgeomx(dim)
      integer d

      do d=1,3
        xgcell(d) = 1
      enddo

      do d=1,dim
        if ((x(d).gt.maxgridx(d)).or.(x(d).lt.mingridx(d))) then
          print *,' >>> ERROR <<< : Particle out of range'
          print *,'    Particle position: x(',i,d,') = ',x(d)
          print *,'    Range: [xmin,xmax](',D,') = 
     &         [',mingridx(d),',',maxgridx(d),']'
          stop
        else
          xgcell(d) = int(real(ngridx(d))/dgeomx(d)*
     &         (x(d)-mingridx(d)) + 1.e0)
        endif
      enddo

      end
      subroutine h_upgrade(parts)

c-----------------------------------------------------------------------
c     Subroutine to evolve smoothing length

c     dt     : time step                                            [in]
c     ntotal : Number of particles                                  [in]
c     mass   : Particle masses                                      [in]
c     vx     : Velocities of all particles                          [in]
c     rho    : Density                                              [in]
c     niac   : Number of interaction pairs                          [in]
c     pair_i : List of first partner of interaction pair            [in]
c     pair_j : List of second partner of interaction pair           [in]
c     dwdx   : Derivative of kernel with respect to x, y and z      [in]
c     hsml   : Smoothing Length                                 [in/out]
  
      use param 
      use declarations_sph, only: dt
      use m_particles 
      implicit none

      type(particles) parts

      integer ntotal, niac
      integer, pointer,dimension(:) :: pair_i, pair_j
      double precision, pointer, dimension(:) :: mass, hsml, rho
      double precision, pointer, dimension(:,:) :: dwdx, vx
     
      integer i,j,k,d
      double precision fac, dvx(dim), hvcc, vcc(maxn), dhsml(maxn)     

      ntotal   = parts%ntotal
      niac     = parts%niac

      pair_i   => parts%pair_i
      pair_j   => parts%pair_j 
      mass     => parts%mass
      dwdx     => parts%dwdx
      hsml     => parts%hsml
      vx       => parts%vx
      rho      => parts%rho

      if (sle.eq.0 ) then     

c---  Keep smoothing length unchanged. 
     
        return
      
      else if (sle.eq.2) then
      
c---  dh/dt = (-1/dim)*(h/rho)*(drho/dt).

        !do i=1,ntotal
        !  vcc(i) = 0.e0
        !enddo
   
        vcc = 0.e0
      
        do k=1,niac
          i = pair_i(k)
          j = pair_j(k)
          do d=1,dim
            dvx(d) = vx(d,j) - vx(d,i) 
          enddo
          hvcc = dvx(1)*dwdx(1,k)
          do d=2,dim
            hvcc = hvcc + dvx(d)*dwdx(d,k)
          enddo    
          vcc(i) = vcc(i) + mass(j)*hvcc/rho(j)
          vcc(j) = vcc(j) + mass(i)*hvcc/rho(i)         
        enddo  
        
        do i = 1, ntotal
          dhsml(i) = (hsml(i)/dim)*vcc(i)
          hsml(i) = hsml(i) + dt*dhsml(i)      
          if (hsml(i).le.0) hsml(i) = hsml(i) - dt*dhsml(i) 
        enddo
    
      else if(sle.eq.1) then
            
        fac = 2.0
        do i = 1, ntotal          
          hsml(i) = fac * (mass(i)/rho(i))**(1./dim)
        enddo
       
      endif 
       
      return
      end subroutine 
      subroutine init_grid(ntotal,hsml,grid,ngridx,ghsmlx,
     &           maxgridx,mingridx,dgeomx)

c----------------------------------------------------------------------      
c   Subroutine to established a pair linked list by sorting grid cell.
c   It is suitable for a homogeneous particle distribution with the 
c   same smoothing length in an instant. A fixed number of particles
c   lie in each cell. 

c     ntotal   : Number of particles                                [in]
c     hsml     : Smoothing Length                                   [in]
c     grid     : array of grid cells                               [out]
c     ngridx   : Number of sorting grid cells in x, y, z-direction [out]
c     ghsmlx   : Smoothing length measured in cells of the grid    [out]
c     maxgridx : Maximum x-, y- and z-coordinate of grid range     [out]
c     mingridx : Minimum x-, y- and z-coordinate of grid range     [out]
c     dgeomx   : x-, y- and z-expansion of grid range              [out]

      use param
      implicit none
C      include 'param.inc'

c     Parameter used for sorting grid cells in the link list algorithm
c     maxngx  : Maximum number of sorting grid cells in x-direction
c     maxngy  : Maximum number of sorting grid cells in y-direction
c     maxngz  : Maximum number of sorting grid cells in z-direction
c     Determining maximum number of sorting grid cells:
c     (For an homogeneous particle distribution:)
c     1-dim. problem: maxngx = maxn ,  maxngy = maxngz = 1
c     2-dim. problem: maxngx = maxngy ~ sqrt(maxn) ,  maxngz = 1
c     3-dim. problem: maxngx = maxngy = maxngz ~ maxn^(1/3)
      integer maxngx,maxngy,maxngz
      parameter ( maxngx  = 100        ,
     &            maxngy  = 100        ,
     &            maxngz  = 1          )
      integer ntotal, grid(maxngx,maxngy,maxngz), ngridx(dim), 
     &        ghsmlx(dim)
      double precision hsml, maxgridx(dim), mingridx(dim), dgeomx(dim)
      integer i, j, k, d, maxng(dim), ngrid(3)
      double precision nppg

c     Averaged number of particles per grid cell

      parameter( nppg = 3.e0 )

c     Initialize parameters: Maximum number of grid cells

      maxng(1) = maxngx
      if (dim.ge.2) then
        maxng(2) = maxngy
        if (dim.eq.3) then
          maxng(3) = maxngz
        endif
      endif
      
      do d=1,3
        ngrid(d) = 1
      enddo
      
c     Range of sorting grid

      maxgridx(1) = x_maxgeom
      mingridx(1) = x_mingeom
      if (dim.ge.2) then
        maxgridx(2) = y_maxgeom
        mingridx(2) = y_mingeom
        if (dim.eq.3) then
          maxgridx(3) = z_maxgeom
          mingridx(3) = z_mingeom
        endif
      endif

      do d=1,dim
         dgeomx(d) = maxgridx(d) - mingridx(d)
      enddo

c     Number of grid cells in x-, y- and z-direction:

      if (dim.eq.1) then
        ngridx(1) = min(int(ntotal/nppg) + 1,maxng(1))
      else if (dim.eq.2) then
        ngridx(1) = min(
     &  int(sqrt(ntotal*dgeomx(1)/(dgeomx(2)*nppg))) + 1,maxng(1))
        ngridx(2) = min(
     &  int(ngridx(1)*dgeomx(2)/dgeomx(1)) + 1,maxng(2))
      else if (dim.eq.3) then
        ngridx(1) = min(int((ntotal*dgeomx(1)*dgeomx(1)/
     &      (dgeomx(2)*dgeomx(3)*nppg))**(1.e0/3.e0)) + 1,maxng(1))
        ngridx(2) = min(
     &      int(ngridx(1)*dgeomx(2)/dgeomx(1)) + 1,maxng(2))
        ngridx(3) = min(
     &  int(ngridx(1)*dgeomx(3)/dgeomx(1)) + 1,maxng(3))
      endif

c     Smoothing Length measured in grid cells:

      do d=1,dim
         ghsmlx(d) = int(real(ngridx(d))*hsml/dgeomx(d)) + 1
      enddo

      do d=1,dim
        ngrid(d) = ngridx(d)
      enddo

c     Initialize grid

      do i=1,ngrid(1)
        do j=1,ngrid(2)
          do k=1,ngrid(3)
            grid(i,j,k) = 0
          enddo
        enddo
      enddo

      end
      subroutine input
      
c----------------------------------------------------------------------
c     Subroutine for loading or generating initial particle information

c     x-- coordinates of particles                                 [out]
c     vx-- velocities of particles                                 [out]
c     mass-- mass of particles                                     [out]
c     rho-- dnesities of particles                                 [out]
c     p-- pressure  of particles                                   [out]
c     u-- internal energy of particles                             [out]
c     itype-- types of particles                                   [out]
c     hsml-- smoothing lengths of particles                        [out]
c     ntotal-- total particle number                               [out]
      
      use param
      use declarations_sph
      implicit none     

      integer i, d, im       

c     load initial particle information from external disk file

      if(config_input) then    
                        
c        open(1,file="../f_xv.dat")
c        open(2,file="../f_state.dat")
c        open(3,file="../f_other.dat")        
      
c        write(*,*)'  **************************************************'
c        write(*,*)'      Loading initial particle configuration...   '       
c        read (1,*) ntotal 
c        write(*,*)'      Total number of particles   ', ntotal    	
c        write(*,*)'  **************************************************'	
c        do i = 1, ntotal         
c          read(1,*)im, (x(d, i),d = 1, dim), (vx(d, i),d = 1, dim)                     
c          read(2,*)im, mass(i), rho(i), p(i), u(i)        
c          read(3,*)im, itype(i), hsml(i)                                        
c        enddo
       
c        close(1)
c        close(2)
c        close(3)         
          
      else 
          
c     generate particle configuration
       
c        if (shocktube) call shock_tube(x, vx, mass, rho, p, u, 
c     &                      itype, hsml, ntotal)                

c        if (shearcavity) call shear_cavity(x, vx, mass, rho, p, u, 
c     &                        itype, hsml, ntotal)

        if (waterjet) call water_jet

        write(*,*)'  **************************************************'
        write(*,*)'   Initial particle configuration generated   '   
        write(*,*)'   Total number of real particles   ', parts%ntotal    
        write(*,*)'   Total number of virtual particles  ', parts%nvirt    
        write(*,*)'  **************************************************'

        if(.not.single_phase)then
         write(*,*) 'Total number of real soil particles:', soil%ntotal
         write(*,*) 'Total number of virtual particles:  ', soil%nvirt
        endif

      endif
   
      return
      end subroutine           
       
       
      subroutine shock_tube(x, vx, mass, rho, p, u, 
     &                        itype, hsml, ntotal)

c----------------------------------------------------------------------     
c     This subroutine is used to generate initial data for the 
c     1 d noh shock tube problem
c     x-- coordinates of particles                                 [out]
c     vx-- velocities of particles                                 [out]
c     mass-- mass of particles                                     [out]
c     rho-- dnesities of particles                                 [out]
c     p-- pressure  of particles                                   [out]
c     u-- internal energy of particles                             [out]
c     itype-- types of particles                                   [out]
c          =1   ideal gas
c     hsml-- smoothing lengths of particles                        [out]
c     ntotal-- total particle number                               [out]

      use param
      implicit none     
      
      integer itype(maxn), ntotal
      double precision x(dim, maxn), vx(dim, maxn), mass(maxn),
     &     rho(maxn), p(maxn), u(maxn), hsml(maxn)
      integer i, d
      double precision space_x     

      ntotal=400
      space_x=0.6/80.      
      
      do i=1,ntotal
        mass(i)=0.75/400.
        hsml(i)=0.015
        itype(i)=1
        do d = 1, dim
          x(d,i) = 0. 
          vx(d,i) = 0.
        enddo        
      enddo                
                
      do i=1,320
        x(1,i)=-0.6+space_x/4.*(i-1)
      enddo
      
      do i=320+1,ntotal
        x(1,i)=0.+space_x*(i-320)
      enddo               
                           
      do i=1,ntotal
        if (x(1,i).le.1.e-8) then
          u(i)=2.5
          rho(i)=1.
          p(i)=1.
        endif 
        if (x(1,i).gt.1.e-8)  then
          u(i)=1.795
          rho(i)=0.25
          p(i)=0.1795
        endif        
      enddo        
	               
      end
      
      subroutine shear_cavity(x, vx, mass, rho, p, u, 
     &                        itype, hsml, ntotal)

c----------------------------------------------------------------------     
c     This subroutine is used to generate initial data for the 
c     2 d shear driven cavity probem with Re = 1
c     x-- coordinates of particles                                 [out]
c     vx-- velocities of particles                                 [out]
c     mass-- mass of particles                                     [out]
c     rho-- dnesities of particles                                 [out]
c     p-- pressure  of particles                                   [out]
c     u-- internal energy of particles                             [out]
c     itype-- types of particles                                   [out]
c          =2   water
c     h-- smoothing lengths of particles                           [out]
c     ntotal-- total particle number                               [out]

      use param
      implicit none     
C      include 'param.inc'
      
      integer itype(maxn), ntotal
      double precision x(dim, maxn), vx(dim, maxn), mass(maxn),
     &     rho(maxn), p(maxn), u(maxn), hsml(maxn)
      integer i, j, d, m, n, mp, np, k
      double precision xl, yl, dx, dy

c     Giving mass and smoothing length as well as other data.

      m = 41
      n = 41
      mp = m-1
      np = n-1
      ntotal = mp * np
      xl = 1.e-3
      yl = 1.e-3
      dx = xl/mp
      dy = yl/np

      do i = 1, mp
         do j = 1, np
             k = j + (i-1)*np
             x(1, k) = (i-1)*dx + dx/2.
             x(2, k) = (j-1)*dy + dy/2.
        enddo
      enddo

      do i = 1, mp*np
         vx(1, i) = 0.
         vx(2, i) = 0.      
        rho (i) = 1000.   
        mass(i) = dx*dy*rho(i)  
        p(i)= 0.   
        u(i)=357.1
        itype(i) = 2
        hsml(i) = dx
      enddo  

      end	 

      subroutine water_jet

c----------------------------------------------------------------------     
c     This subroutine is used to generate initial data for the 
c     2 d water jet impacting probem with Re = ?
c     x-- coordinates of particles                                 [out]
c     vx-- velocities of particles                                 [out]
c     mass-- mass of particles                                     [out]
c     rho-- dnesities of particles                                 [out]
c     p-- pressure  of particles                                   [out]
c     u-- internal energy of particles                             [out]
c     itype-- types of particles                                   [out]
c          =2   water
c     h-- smoothing lengths of particles                           [out]
c     ntotal-- total particle number                               [out]

      use param
      use declarations_sph
      implicit none     
      
      integer  ntotal, bntotal
      integer i, j, d, k, ntotal_nozzle
      type(block) nozzle, tank
      type(material), pointer :: property
      double precision xleft,xright,ybottom
      logical :: dbg = .false.
      real AAA

      if(dbg) write(*,*) 'In water_jet...'      

c     Set nozzle and tank geometry parameters

      if(trim(particle_size)=='small') 
     &   call wasserjet%set(dr=0.2d0,L=2.d0,H=0.6d0,mdr=10,dj=10.d0,
     &        mdj=500,ds=0.4d0, mL=100,mH=30)
      if(trim(particle_size)=='large')
     &   call wasserjet%set(dr=0.2d0,L=2.d0,H=0.6d0,mdr=5,dj=10.d0,
     &        mdj=250,ds=0.4d0, mL=50,mH=15)
       if(trim(particle_size)=='smallnozzle')
     &   call wasserjet%set(dr=0.1d0,L=2.d0,H=0.6d0,mdr=5,dj=10.d0,
     &        mdj=500,ds=0.4d0, mL=100,mH=30)
        if(trim(particle_size)=='bui')
!     &   call wasserjet%set(dr=0.02d0,L=0.5d0,H=0.2d0,mdr=4,dj=2.d0,
!     &        mdj=400,ds=0.1d0, mL=100,mH=40)
     &   call wasserjet%set(dr=0.02d0,L=0.5d0,H=0.2d0,mdr=2,dj=2.d0,
     &        mdj=200,ds=0.1d0, mL=50,mH=20)
        if(trim(particle_size)=='dambreak')
     &   call wasserjet%set(L=0.8d0,H=0.2d0, ds=0.1d0, mL=160,mH=40)
        if(trim(particle_size)=='damsmall')
!     &   call wasserjet%set(L=0.8d0,H=0.06d0, ds=0.24d0, mL=320,mH=24)  !smallest
     &   call wasserjet%set(L=0.8d0,H=0.06d0, ds=0.24d0, mL=160,mH=12)  !coarse
!     &   call wasserjet%set(L=0.8d0,H=0.03d0, ds=0.27d0, mL=320,mH=12)  !smallest
!     &   call wasserjet%set(L=0.8d0,H=0.11d0, ds=0.19d0, mL=160,mH=22) !cube


C     Nozzle particle entrance

      call nozzle%set(xl = wasserjet%dr, yl = wasserjet%dj,
     &                 m = wasserjet%mdr, n = wasserjet%mdj)
      k = nozzle%m*nozzle%n
      allocate(nozzle%x(k),nozzle%y(k))
      call nozzle%cell_center
      nozzle%x = nozzle%x - wasserjet%dr/2.
      nozzle%y = nozzle%y - wasserjet%immerse

C     Paticles in tank
 
      call tank%set(xl = wasserjet%L, yl = wasserjet%H,  
     &               m = wasserjet%mL, n = wasserjet%mH)
      k = tank%m*tank%n
      allocate(tank%x(k),tank%y(k))
      call tank%cell_center       
      tank%x = tank%x  - wasserjet%L/2.
      tank%y = (tank%y + wasserjet%ds)*(-1.0)

c -----------------------Phase I------------------------------

      xleft = -0.9; xright = 0.9; ybottom = -0.9
      if(trim(particle_size)=='bui')then
         xleft = -0.225; xright = 0.225; ybottom = -0.275
      elseif(trim(particle_size)=='dambreak')then
         xleft = -0.1; xright = 0.1; ybottom = -0.275
      endif

      if(trim(particle_size)=='damsmall')then
!         xleft = -0.05; xright = 0.05; ybottom = -0.29   !cube
         xleft = -0.1; xright = 0.1; ybottom = -0.29      ! smallest
      endif

      k = 0
                                          if(with_nozzle)then 
      ntotal_nozzle = nozzle%m*nozzle%n
      do i =1, ntotal_nozzle
         k = k + 1
         parts%x(1, k) = nozzle%x(i)
         parts%x(2, k) = nozzle%y(i)
      enddo
                                          endif !nozzle

      do i = 1, tank%m*tank%n
      if(tank%x(i)<xleft.or.tank%x(i)>xright.or.tank%y(i)<ybottom)then
         else
            k = k + 1
            parts%x(1,k) = tank%x(i)
            parts%x(2,k) = tank%y(i)
         endif
      enddo
      parts%ntotal = k

      if(trim(particle_size)=='dambreak')then
         xleft = -9999.0; xright = 9999.0
      endif
      
!      if(trim(particle_size)=='damsmall')then   !!! IFORT is shit!
         !xleft = -9999.0d0
         !xright = 9999.0d0
!      endif

      do i = 1, tank%m*tank%n
      if(tank%x(i)<xleft.or.tank%x(i)>xright.or.tank%y(i)<ybottom)then
            k = k + 1
            parts%x(1,k) = tank%x(i)
            parts%x(2,k) = tank%y(i)
        endif
      enddo
      parts%nvirt = k - parts%ntotal

c      parts%nvirt = 0
     
c Basic settings for particles

      ntotal = parts%ntotal; bntotal = parts%nvirt

      parts%vol(1:ntotal+bntotal) = tank%dx*tank%dy
      parts%hsml(1:ntotal+bntotal)= tank%dx
      parts%zone(1:ntotal_nozzle) = 1

      if(trim(parts%imaterial)=='water')then
         parts%itype(1:ntotal) = 2
         parts%itype(ntotal+1:ntotal+bntotal) = -2
      elseif(trim(parts%imaterial)=='soil')then
         parts%itype(1:ntotal) = 3
         parts%itype(ntotal+1:ntotal+bntotal) = -3
      endif

c      do i = 1, parts%ntotal
c         if(parts%x(1,i)<-0.9.or.parts%x(1,i)>0.9.or.parts%x(2,i)<-0.9)
c     &      parts%itype(i) = -2
c      enddo

c     Set initial conditions of particles

      property => parts%material
      do i = 1,parts%ntotal+parts%nvirt
         parts%vx(1,i) = 0.
         parts%vx(2,i) = 0.
         parts%rho(i) = property%rho0
         parts%p(i) = parts%rho(i)*gravity*(parts%x(2,i)+wasserjet%ds)  !0.
         if(parts%x(2,i)>-wasserjet%ds)then
            parts%vx(2,i) = inlet_velocity
            parts%p(i) = 0
         endif
         !if(abs(parts%x(1,i))>0.1) parts%p(i)=0.d0  ! cube 0.05 !smallest 0.1
      enddo

      if(trim(parts%imaterial)=='soil')then
         do i = 1, parts%ntotal+parts%nvirt   
            parts%sxx(i) = -0.3*parts%p(i)
            parts%syy(i) = 0.d0
            parts%sxy(i) = 0.d0
         enddo
      endif

      call initial_density(parts)

      parts%vof(1:ntotal_nozzle) = 1.0
      parts%vof(ntotal_nozzle+1:ntotal+bntotal) = 0.5

      parts%rho(1:ntotal+bntotal) = parts%rho(1:ntotal+bntotal)*
     &                              parts%vof(1:ntotal+bntotal)

      parts%mass(1:ntotal+bntotal) = parts%vol(1:ntotal+bntotal)
     &                             * parts%rho(1:ntotal+bntotal)

c-------------------------------soil input---------------------------------

      if(single_phase)return

      k = 0; ntotal = 0; bntotal = 0
      do i = 1, parts%ntotal+parts%nvirt
         if(parts%x(2,i)>-wasserjet%ds)cycle
         k = k + 1
         soil%x(:,k)   = parts%x(:,i)
         soil%vol(k)   = parts%vol(i)
         soil%hsml(k)  = parts%hsml(i) 
c
         soil%p(k)     = parts%p(i)
c
         if(parts%itype(i)==-2)then
            bntotal = bntotal + 1
            soil%itype(k) = -3
         elseif(parts%itype(i)==2)then
            ntotal = ntotal + 1
            soil%itype(k) =  3
         endif
      enddo
      soil%ntotal = ntotal; soil%nvirt = bntotal

c set initial conditions for soil particles

      property => soil%material
      do i = 1, soil%ntotal+soil%nvirt
         soil%vx(:,i) = 0.
         soil%rho(i)  = property%rho0
         if(dry_soil)then
         soil%p(i) = soil%rho(i)*gravity*(soil%x(2,i)+wasserjet%ds)
         else
         soil%p(i) = soil%rho(i)*gravity*(soil%x(2,i)+wasserjet%ds)
     &             - soil%p(i)
         endif      
      enddo

      do i = 1, soil%ntotal+soil%nvirt   
         soil%sxx(i) = -0.3*soil%p(i)
         soil%syy(i) = 0.d0
         soil%sxy(i) = 0.d0
      enddo

      call initial_density(soil)       

      soil%vof(1:ntotal+bntotal) = 0.5
      soil%rho(1:ntotal+bntotal) = soil%rho(1:ntotal+bntotal)*
     &                             soil%vof(1:ntotal+bntotal)      

      soil%mass(1:ntotal+bntotal) = soil%vol(1:ntotal+bntotal)
     &                            * soil%rho(1:ntotal+bntotal)


      if(dry_soil)then
         parts%ntotal = ntotal_nozzle   ! no water in the tank
         parts%nvirt  = 0
      endif
c--------------------------------------------------------------------

      return
      end subroutine


      subroutine int_force(parts)

c----------------------------------------------------------------------
c   Subroutine to calculate the internal forces on the right hand side 
c   of the Navier-Stokes equations, i.e. the pressure gradient and the
c   gradient of the viscous stress tensor, used by the time integration. 
c   Moreover the entropy production due to viscous dissipation, tds/dt, 
c   and the change of internal energy per mass, de/dt, are calculated. 
 
c     itimestep: Current timestep number                            [in]
c     dt     :   Time step                                          [in]
c     ntotal : Number of particles                                  [in]
c     hsml   : Smoothing Length                                     [in]
c     mass   : Particle masses                                      [in]
c     vx     : Velocities of all particles                          [in]
c     niac   : Number of interaction pairs                          [in]
c     rho    : Density                                              [in]
c     eta    : Dynamic viscosity                                    [in]
c     pair_i : List of first partner of interaction pair            [in]
c     pair_j : List of second partner of interaction pair           [in]
c     dwdx   : Derivative of kernel with respect to x, y and z      [in]
c     itype  : Type of particle (material types)                    [in]
c     u      : Particle internal energy                             [in]
c     x      : Particle coordinates                                 [in]
c     itype  : Particle type                                        [in]
c     t      : Particle temperature                             [in/out]
c     c      : Particle sound speed                                [out]
c     p      : Particle pressure                                   [out]
c     dvxdt  : Acceleration with respect to x, y and z             [out] 
c     tdsdt  : Production of viscous entropy                       [out]
c     dedt   : Change of specific internal energy                  [out]

      use param
      use m_particles
      implicit none

      type(particles) parts
      
      integer ntotal,niac
      integer, pointer, dimension(:) :: pair_i, pair_j 
      double precision, pointer, dimension(:) :: hsml, mass, rho, p
      double precision, pointer, dimension(:,:) :: dwdx, vx, dvxdt
      double precision, pointer, dimension(:) :: sxx, sxy, syy, 
     *                                           szz, sxz, syz
      double precision, pointer, dimension(:) :: vof
      double precision h, hvcc, he, rhoij
      integer i, j, k, d

      ntotal = parts%ntotal + parts%nvirt
      niac = parts%niac

      pair_i   => parts%pair_i
      pair_j   => parts%pair_j
      mass     => parts%mass
      dwdx     => parts%dwdx
      vx       => parts%vx
      rho      => parts%rho
      p        => parts%p
      dvxdt    => parts%dvx
      sxx      => parts%sxx
      syy      => parts%syy
      sxy      => parts%sxy
      vof      => parts%vof

c      Calculate SPH sum for pressure force -p,a/rho
c      and viscous force (eta Tab),b/rho
c      and the internal energy change de/dt due to -p/rho vc,c

      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        he = 0.e0
        
c     For SPH algorithm 1

        rhoij = 1.e0/(rho(i)*rho(j))        
        if(pa_sph.eq.1) then  
          do d=1,dim
        
c     Pressure part
                    
            h = -(p(i) + p(j))*dwdx(d,k)
            he = he + (vx(d,j) - vx(d,i))*h

c     Viscous force

            if (visc) then 
            
             if (d.eq.1) then
            
c     x-coordinate of acceleration

               h = h + (sxx(i) + sxx(j))*dwdx(1,k)
               if (dim.ge.2) then
                 h = h + (sxy(i) + sxy(j))*dwdx(2,k)
                 if (dim.eq.3) then
                   h = h + (sxz(i) + sxz(j))*dwdx(3,k)
                 endif
               endif            
             elseif (d.eq.2) then
            
c     y-coordinate of acceleration

               h = h + (sxy(i) + sxy(j))*dwdx(1,k)
     &               + (syy(i) + syy(j))*dwdx(2,k)
               if (dim.eq.3) then
                 h = h + (syz(i) + syz(j))*dwdx(3,k)
               endif             
             elseif (d.eq.3) then
            
c     z-coordinate of acceleration

               h = h + (sxz(i) + sxz(j))*dwdx(1,k)
     &               + (syz(i) + syz(j))*dwdx(2,k)
     &               + (szz(i) + szz(j))*dwdx(3,k)            
             endif
           endif             
           h = h*rhoij
           dvxdt(d,i) = dvxdt(d,i) + mass(j)*h
           dvxdt(d,j) = dvxdt(d,j) - mass(i)*h
          enddo
          he = he*rhoij
          
c     For SPH algorithm 2
          
        else if (pa_sph.eq.2) then 
          do d=1,dim                
            h = -(p(i)*vof(i)/rho(i)**2 + 
     &            p(j)*vof(j)/rho(j)**2)*dwdx(d,k) 
            he = he + (vx(d,j) - vx(d,i))*h

c     Viscous force

            if (visc) then             
             if (d.eq.1) then
                       
c     x-coordinate of acceleration

               h = h + (sxx(i)*vof(i)/rho(i)**2 +
     &                  sxx(j)*vof(j)/rho(j)**2)*dwdx(1,k)
               if (dim.ge.2) then
                 h = h + (sxy(i)*vof(i)/rho(i)**2 + 
     &                    sxy(j)*vof(j)/rho(j)**2)*dwdx(2,k)
                 if (dim.eq.3) then
                   h = h + (sxz(i)/rho(i)**2 + 
     &                      sxz(j)/rho(j)**2)*dwdx(3,k)
                 endif
               endif            
             elseif (d.eq.2) then
            
c     y-coordinate of acceleration

               h = h + (sxy(i)*vof(i)/rho(i)**2  
     &               +  sxy(j)*vof(j)/rho(j)**2)*dwdx(1,k)
     &               + (syy(i)*vof(i)/rho(i)**2  
     &               +  syy(j)*vof(j)/rho(j)**2)*dwdx(2,k)
               if (dim.eq.3) then
                 h = h + (syz(i)/rho(i)**2  
     &                 +  syz(j)/rho(j)**2)*dwdx(3,k)
               endif              
             elseif (d.eq.3) then
            
c     z-coordinate of acceleration

               h = h + (sxz(i)/rho(i)**2 + 
     &                  sxz(j)/rho(j)**2)*dwdx(1,k)
     &               + (syz(i)/rho(i)**2 + 
     &                  syz(j)/rho(j)**2)*dwdx(2,k)
     &               + (szz(i)/rho(i)**2 + 
     &                  szz(j)/rho(j)**2)*dwdx(3,k)            
             endif            
           endif              
           dvxdt(d,i) = dvxdt(d,i) + mass(j)*h
           dvxdt(d,j) = dvxdt(d,j) - mass(i)*h
          enddo
        endif        
      enddo

      return
      end subroutine

c---------------------------------------------------------------------
      subroutine Jaumann_rate(parts)
c----------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts
      
      integer ntotal,niac
      integer, pointer, dimension(:) :: pair_i, pair_j 
      double precision, pointer, dimension(:,:) :: dwdx, vx
      double precision, pointer, dimension(:) :: mass, rho, eta, wxy
      double precision, pointer, dimension(:) :: sxx,syy,szz,sxy,sxz,syz 
      double precision, pointer, dimension(:) :: txx,tyy,tzz,txy,txz,tyz 
      type(material), pointer :: soil

      double precision  dvx(dim), hxx, hyy, hzz, hxy, hxz, hyz 
      integer i, j, k, d

      ntotal = parts%ntotal + parts%nvirt
      niac = parts%niac

      pair_i   => parts%pair_i
      pair_j   => parts%pair_j
      mass     => parts%mass
      dwdx     => parts%dwdx
      vx       => parts%vx
      rho      => parts%rho
      eta      => parts%eta
      sxx      => parts%sxx;  txx => parts%txx
      syy      => parts%syy;  tyy => parts%tyy
      sxy      => parts%sxy;  txy => parts%txy
      wxy      => parts%wxy
      soil     => parts%material

c     Hook's law

      do i = 1, ntotal
         parts%dsxx(i) = parts%dsxx(i)+eta(i)*txx(i)   ! No accumulation origionaly
         parts%dsxy(i) = parts%dsxy(i)+eta(i)*txy(i)
         parts%dsyy(i) = parts%dsyy(i)+eta(i)*tyy(i)
         parts%dp(i)   = parts%dp(i) - soil%k*parts%vcc(i)  
      enddo         
     
c     spin tensor

      wxy = 0.d0

      do k=1,niac
          i = pair_i(k)
          j = pair_j(k)
          do d=1,dim
            dvx(d) = vx(d,j) - vx(d,i)
          enddo
          if (dim.eq.1) then 
            !hxx = 0.5e0*dvx(1)*dwdx(1,k)        
          else if (dim.eq.2) then           
            hxy = 0.5e0*(dvx(1)*dwdx(2,k) - dvx(2)*dwdx(1,k))
          else if (dim.eq.3) then
!            hxy = dvx(1)*dwdx(2,k) + dvx(2)*dwdx(1,k)
!            hxz = dvx(1)*dwdx(3,k) + dvx(3)*dwdx(1,k)          
!            hyz = dvx(2)*dwdx(3,k) + dvx(3)*dwdx(2,k)
          endif                              
          if (dim.eq.1) then 
!            txx(i) = txx(i) + mass(j)*hxx/rho(j)
!            txx(j) = txx(j) + mass(i)*hxx/rho(i)                 
          else if (dim.eq.2) then           
            wxy(i) = wxy(i) + mass(j)*hxy/rho(j)
            wxy(j) = wxy(j) + mass(i)*hxy/rho(i)            
          else if (dim.eq.3) then
!            txy(i) = txy(i) + mass(j)*hxy/rho(j)
!            txy(j) = txy(j) + mass(i)*hxy/rho(i) 
!            txz(i) = txz(i) + mass(j)*hxz/rho(j)
!            txz(j) = txz(j) + mass(i)*hxz/rho(i)                     
!            tyz(i) = tyz(i) + mass(j)*hyz/rho(j)
!            tyz(j) = tyz(j) + mass(i)*hyz/rho(i)   
          endif                              
       enddo
   
c   Jaumann rate

      do i = 1, ntotal
         parts%dsxx(i) = parts%dsxx(i)+2.0*sxy(i)*wxy(i)
         parts%dsxy(i) = parts%dsxy(i)-(sxx(i)-syy(i))*wxy(i)
         parts%dsyy(i) = parts%dsyy(i)-2.0*sxy(i)*wxy(i)
      enddo         

      return
      end subroutine

!------------------------------------------------------------
      subroutine mohr_coulomb_failure_criterion(soil)
!------------------------------------------------------------
      use m_particles
      implicit none

      type(particles) soil

      double precision, pointer, dimension(:) :: sxx,syy,sxy
      double precision, pointer, dimension(:) :: p
      type(material), pointer :: property
      double precision yield, phi, skale, cohesion, tmax
      integer i, k, ntotal

      ntotal = soil%ntotal+soil%nvirt
      sxx => soil%sxx
      syy => soil%syy
      sxy => soil%sxy
      p   => soil%p
      property => soil%material
      
      cohesion = property%cohesion
      phi      = property%phi
   
      k = 0
      soil%fail = 0
      do i = 1, ntotal
         tmax  = sqrt(((sxx(i)-syy(i))/2)**2+sxy(i)**2)
         if(tmax<1.e-6)cycle
         yield = cohesion*cos(phi)+p(i)*sin(phi)

         if(yield<=0.)then    ! <
            yield=0.; p(i)=-cohesion*tan(phi)**(-1.0)
            soil%rho(i) = property%rho0
         endif

!         if(yield<=0.)then   ! Collapse
!            sxx(i) = sxx(i)+p(i)-cohesion*tan(phi)**(-1.0)
!            syy(i) = syy(i)+p(i)-cohesion*tan(phi)**(-1.0)
!            p(i)   = 0.
!         endif

         if(tmax>yield)then
!         if(yield>0.and.tmax>yield)then
            k = k + 1
            soil%fail(i) = 1 
            skale = yield/tmax
            sxx(i) = skale * sxx(i)
            sxy(i) = skale * sxy(i)
            syy(i) = skale * syy(i)
         endif
         !sxx(i) = 0.; sxy(i) = 0.; syy(i) = 0.
      enddo
      soil%nfail = k

      return
      end subroutine

!------------------------------------------------------------
      subroutine drucker_prager_failure_criterion(soil)
!------------------------------------------------------------
      use m_particles
      implicit none

      type(particles) soil

      double precision, pointer, dimension(:) :: sxx,syy,sxy
      double precision, pointer, dimension(:) :: p
      type(material), pointer :: property
      double precision yield, phi, skale, cohesion, tmax, alpha1,I1,J2
      integer i, k, ntotal
        
      !if(soil%itimestep==82)write(*,*) 'in drucker...'
 
      ntotal = soil%ntotal+soil%nvirt
      sxx => soil%sxx
      syy => soil%syy
      sxy => soil%sxy
      p   => soil%p
      property => soil%material
      
      cohesion = property%cohesion
      phi      = property%phi
      alpha1   = tan(phi)/sqrt(9.+12.*tan(phi)**2.)
   
      k = 0
      soil%fail = 0
      do i = 1, ntotal
         !tmax  = sqrt(((sxx(i)-syy(i))/2)**2+sxy(i)**2)
         !if(tmax<1.e-6)cycle
         !yield = cohesion*cos(phi)+p(i)*sin(phi)


         if(p(i)<0.)then    ! <
            !k = k + 1
            !soil%fail(i) = 1
            p(i)=0.d0
            !soil%rho(i) = property%rho0
         endif

!         if(yield<=0.)then   ! Collapse
!            sxx(i) = sxx(i)+p(i)-cohesion*tan(phi)**(-1.0)
!            syy(i) = syy(i)+p(i)-cohesion*tan(phi)**(-1.0)
!            p(i)   = 0.
!         endif

         I1 = 3.*p(i) 

         J2 = sxx(i)**2.+2.*sxy(i)**2.+syy(i)**2.+(sxx(i)+syy(i))**2.
         J2 = sqrt(J2/2.)+1.d-6
         !if(J2<1.e-6)cycle

         if(J2>alpha1*I1)then
!         if(yield>0.and.tmax>yield)then
            k = k + 1
            soil%fail(i) = 1 
            skale = alpha1*I1/J2
            sxx(i) = skale * sxx(i)
            sxy(i) = skale * sxy(i)
            syy(i) = skale * syy(i)
        endif

      enddo
      soil%nfail = k

      return
      end subroutine

c ---------------------------------------------------------------------
      subroutine shear_strain_rate(parts)
c----------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts
      
      integer ntotal,niac
      integer, pointer, dimension(:) :: pair_i, pair_j 
      double precision, pointer, dimension(:) ::  mass, rho
      double precision, pointer, dimension(:,:) :: dwdx, vx
      double precision, pointer, dimension(:) :: txx, tyy, tzz, 
     &                                           txy, txz, tyz 
      double precision dvx(dim), hxx, hyy, hzz, hxy, hxz, hyz
      integer i, j, k, d

      ntotal = parts%ntotal + parts%nvirt
      niac = parts%niac

      pair_i   => parts%pair_i
      pair_j   => parts%pair_j
      mass     => parts%mass
      rho      => parts%rho
      dwdx     => parts%dwdx
      vx       => parts%vx
      txx      => parts%txx
      tyy      => parts%tyy
      tzz      => parts%tzz
      txy      => parts%txy
      txz      => parts%txz
      tyz      => parts%tyz

      txx(1:ntotal) = 0.e0
      if(dim>=2)then
         tyy(1:ntotal) = 0.e0
         txy(1:ntotal) = 0.e0
      endif
      if(dim==3)then
         tzz(1:ntotal) = 0.e0
         txz(1:ntotal) = 0.e0
         tyz(1:ntotal) = 0.e0
      endif
      
c     Calculate SPH sum for shear tensor Tab = va,b + vb,a - 2/3 delta_ab vc,c

        do k=1,niac
          i = pair_i(k)
          j = pair_j(k)
          do d=1,dim
             dvx(d) = vx(d,j) - vx(d,i)
          enddo
          if (dim.eq.1) then 
             hxx = 2.e0*dvx(1)*dwdx(1,k)        
          else if (dim.eq.2) then           
             hxx = 2.e0*dvx(1)*dwdx(1,k) -  dvx(2)*dwdx(2,k) 
             hxy = dvx(1)*dwdx(2,k) + dvx(2)*dwdx(1,k)
             hyy = 2.e0*dvx(2)*dwdx(2,k) - dvx(1)*dwdx(1,k)
          else if (dim.eq.3) then
             hxx = 2.e0*dvx(1)*dwdx(1,k) - dvx(2)*dwdx(2,k) 
     &                                   - dvx(3)*dwdx(3,k) 
             hxy = dvx(1)*dwdx(2,k) + dvx(2)*dwdx(1,k)
             hxz = dvx(1)*dwdx(3,k) + dvx(3)*dwdx(1,k)          
             hyy = 2.e0*dvx(2)*dwdx(2,k) - dvx(1)*dwdx(1,k)        
     &                                   - dvx(3)*dwdx(3,k)
             hyz = dvx(2)*dwdx(3,k) + dvx(3)*dwdx(2,k)
             hzz = 2.e0*dvx(3)*dwdx(3,k) - dvx(1)*dwdx(1,k)
     &                                  - dvx(2)*dwdx(2,k)
          endif                              
          hxx = 2.e0/3.e0*hxx
          hyy = 2.e0/3.e0*hyy
          hzz = 2.e0/3.e0*hzz
          if (dim.eq.1) then 
             txx(i) = txx(i) + mass(j)*hxx/rho(j)
             txx(j) = txx(j) + mass(i)*hxx/rho(i)                 
          else if (dim.eq.2) then           
             txx(i) = txx(i) + mass(j)*hxx/rho(j)
             txx(j) = txx(j) + mass(i)*hxx/rho(i)   
             txy(i) = txy(i) + mass(j)*hxy/rho(j)
             txy(j) = txy(j) + mass(i)*hxy/rho(i)            
             tyy(i) = tyy(i) + mass(j)*hyy/rho(j)
             tyy(j) = tyy(j) + mass(i)*hyy/rho(i)          
          else if (dim.eq.3) then
             txx(i) = txx(i) + mass(j)*hxx/rho(j)
             txx(j) = txx(j) + mass(i)*hxx/rho(i)   
             txy(i) = txy(i) + mass(j)*hxy/rho(j)
             txy(j) = txy(j) + mass(i)*hxy/rho(i) 
             txz(i) = txz(i) + mass(j)*hxz/rho(j)
             txz(j) = txz(j) + mass(i)*hxz/rho(i)                     
             tyy(i) = tyy(i) + mass(j)*hyy/rho(j)
             tyy(j) = tyy(j) + mass(i)*hyy/rho(i)
             tyz(i) = tyz(i) + mass(j)*hyz/rho(j)
             tyz(j) = tyz(j) + mass(i)*hyz/rho(i)   
             tzz(i) = tzz(i) + mass(j)*hzz/rho(j)
             tzz(j) = tzz(j) + mass(i)*hzz/rho(i)                 
          endif                              
        enddo

      return
      end subroutine

c ---------------------------------------------------------------------
      subroutine newtonian_fluid(parts)
c----------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts
      integer ntotal

      ntotal = parts%ntotal + parts%nvirt

      parts%sxx(1:ntotal) = parts%eta(1:ntotal)*parts%txx(1:ntotal)
      parts%syy(1:ntotal) = parts%eta(1:ntotal)*parts%tyy(1:ntotal)
      parts%sxy(1:ntotal) = parts%eta(1:ntotal)*parts%txy(1:ntotal)

      return
      end subroutine

!---------------------------------------------------------------------
      subroutine plastic_flow_rule(parts)
!---------------------------------------------------------------------
      use m_particles
      implicit none

      type(particles) parts
      double precision, pointer, dimension(:) :: dsxx,dsxy,dsyy,vcc
      double precision, pointer, dimension(:) :: sxx, sxy, syy
      type(material), pointer :: property
      double precision alpha, phi, K, G, J2, sde, dlambda
      double precision exx, exy, eyy                ! total strain rate
      double precision :: small_value = 1.d-10
      integer i, ntotal

      ntotal = parts%ntotal + parts%nvirt

      dsxx => parts%dsxx
      dsxy => parts%dsxy
      dsyy => parts%dsyy
      vcc  => parts%vcc
      sxx => parts%sxx
      sxy => parts%sxy
      syy => parts%syy

      property => parts%material
      phi = property%phi
      k   = property%k
      alpha = tan(phi)/sqrt(9.+12.*tan(phi)**2.)
      
      do i = 1, ntotal
                            !if(parts%fail(i)==1)then

      exx = parts%txx(i)/2.+parts%vcc(i)/3.   ! Due to this, this should before Jaumman
      exy = parts%txy(i)/2.
      eyy = parts%tyy(i)/2.+parts%vcc(i)/3.

      sde = sxx(i)*exx+2.*sxy(i)*exy+syy(i)*eyy
      J2 = (sxx(i)**2.+2.*sxy(i)**2.+syy(i)**2.+(sxx(i)+syy(i))**2.)/2.
      J2 = J2 + small_value

      G = parts%eta(i)
      dlambda = (3.*alpha*K*vcc(i)+G/sqrt(J2)*sde)/(9.*alpha**2.*K+G)

      !dsxx(i) = dsxx(i)-dlambda*(3.*alpha*K+G/sqrt(J2)*sxx(i))
      dsxx(i) = dsxx(i)-dlambda*(G/sqrt(J2)*sxx(i))
      dsxy(i) = dsxy(i)-dlambda*(G/sqrt(J2)*sxy(i))
      !dsyy(i) = dsyy(i)-dlambda*(3.*alpha*K+G/sqrt(J2)*syy(i))
      dsyy(i) = dsyy(i)-dlambda*(G/sqrt(J2)*syy(i))

      !parts%p(i) = parts%p(i) + 3.*k*alpha*dlambda*0.000005
      parts%dp(i) = parts%dp(i) + 3.*k*alpha*dlambda

c Accumulative deviatoric strain
 
      parts%epsilon_p(i) = parts%epsilon_p(i) 
     &                   + dlambda*sxy(i)/(2*sqrt(J2))*0.000005

                            !endif ! Fail
      enddo
      
      return
      end subroutine

!-----------------------------------------------------------------------
      subroutine velocity_divergence(parts)
!-----------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts      
      integer, pointer, dimension(:) :: pair_i, pair_j
      double precision, pointer, dimension(:) :: mass, rho, vcc
      double precision, pointer, dimension(:,:) :: vx, dwdx
      integer i,j,k,d, ntotal, niac
      double precision dvx(dim), hvcc
      
      pair_i => parts%pair_i
      pair_j => parts%pair_j
      mass   => parts%mass
      rho    => parts%rho
      vcc    => parts%vcc
      vx     => parts%vx
      dwdx   => parts%dwdx

      ntotal = parts%ntotal + parts%nvirt
      niac   = parts%niac 

      do i=1,ntotal
        vcc(i) = 0.e0         
      enddo
    
      do k=1,niac
        i = pair_i(k)
        j = pair_j(k)
        do d=1,dim
          dvx(d) = vx(d,j) - vx(d,i) 
        enddo        
        hvcc = dvx(1)*dwdx(1,k)
        do d=2,dim
          hvcc = hvcc + dvx(d)*dwdx(d,k)
        enddo    
         vcc(i) = vcc(i) + mass(j)*hvcc/rho(j)
         vcc(j) = vcc(j) + mass(i)*hvcc/rho(i)
      enddo  
   
      return
      end subroutine


        subroutine kernel(r,dx,hsml,w,dwdx)   

c----------------------------------------------------------------------
c   Subroutine to calculate the smoothing kernel wij and its 
c   derivatives dwdxij.
c     if skf = 1, cubic spline kernel by W4 - Spline (Monaghan 1985)
c            = 2, Gauss kernel   (Gingold and Monaghan 1981) 
c            = 3, Quintic kernel (Morris 1997)

c     r    : Distance between particles i and j                     [in]
c     dx   : x-, y- and z-distance between i and j                  [in]  
c     hsml : Smoothing length                                       [in]
c     w    : Kernel for all interaction pairs                      [out]
c     dwdx : Derivative of kernel with respect to x, y and z       [out]

      use param
      implicit none
      
      double precision r, dx(dim), hsml, w, dwdx(dim)
      integer i, j, d      
      double precision q, dw, factor
      logical :: dbg = .false.

      if(dbg) write(*,*) 'In kernel...'

      q = r/hsml 
      w = 0.e0
      do d=1,dim         
        dwdx(d) = 0.e0
      enddo   

      if (skf.eq.1) then     
        if (dim.eq.1) then
          factor = 1.e0/hsml
        elseif (dim.eq.2) then
          factor = 15.e0/(7.e0*pi*hsml*hsml)
        elseif (dim.eq.3) then
          factor = 3.e0/(2.e0*pi*hsml*hsml*hsml)
        else
         print *,' >>> Error <<< : Wrong dimension: Dim =',dim
         stop
        endif                                           
        if (q.ge.0.and.q.le.1.e0) then          
          w = factor * (2./3. - q*q + q**3 / 2.)
          do d = 1, dim
            dwdx(d) = factor * (-2.+3./2.*q)/hsml**2 * dx(d)       
          enddo   
        else if (q.gt.1.e0.and.q.le.2) then          
          w = factor * 1.e0/6.e0 * (2.-q)**3 
          do d = 1, dim
            dwdx(d) =-factor * 1.e0/6.e0 * 3.*(2.-q)**2/hsml * (dx(d)/r)        
          enddo              
	else
	  w=0.
          do d= 1, dim
            dwdx(d) = 0.
          enddo             
        endif     
                                    
      else if (skf.eq.2) then
      
        factor = 1.e0 / (hsml**dim * pi**(dim/2.))      
	if(q.ge.0.and.q.le.3) then
	  w = factor * exp(-q*q)
          do d = 1, dim
            dwdx(d) = w * ( -2.* dx(d)/hsml/hsml)
          enddo 
	else
	  w = 0.
          do d = 1, dim
            dwdx(d) = 0.
          enddo 	   
	endif	       
	
      else if (skf.eq.3) then	
      
        if (dim.eq.1) then
          factor = 1.e0 / (120.e0*hsml)
        elseif (dim.eq.2) then
          factor = 7.e0 / (478.e0*pi*hsml*hsml)
        elseif (dim.eq.3) then
          factor = 1.e0 / (120.e0*pi*hsml*hsml*hsml)
        else
         print *,' >>> Error <<< : Wrong dimension: Dim =',dim
         stop
        endif              
	if(q.ge.0.and.q.le.1) then
          w = factor * ( (3-q)**5 - 6*(2-q)**5 + 15*(1-q)**5 )
          do d= 1, dim
            dwdx(d) = factor * ( (-120 + 120*q - 50*q**2) 
     &                        / hsml**2 * dx(d) )
          enddo 
	else if(q.gt.1.and.q.le.2) then
          w = factor * ( (3-q)**5 - 6*(2-q)**5 )
          do d= 1, dim
            dwdx(d) = factor * (-5*(3-q)**4 + 30*(2-q)**4)  
     &                       / hsml * (dx(d)/r) 
          enddo 
        else if(q.gt.2.and.q.le.3) then
          w = factor * (3-q)**5 
          do d= 1, dim
            dwdx(d) = factor * (-5*(3-q)**4) / hsml * (dx(d)/r) 
          enddo 
        else   
	  w = 0.
          do d = 1, dim
            dwdx(d) = 0.
          enddo  
        endif                      
                
      endif 
		
      end
      subroutine link_list(itimestep, ntotal,hsml,x,niac,pair_i,
     &           pair_j,w,dwdx,countiac)
     
c----------------------------------------------------------------------
c   Subroutine to calculate the smoothing funciton for each particle and
c   the interaction parameters used by the SPH algorithm. Interaction 
c   pairs are determined by using a sorting grid linked list  

c     itimestep : Current time step                                 [in]
c     ntotal    : Number of particles                               [in]
c     hsml      : Smoothing Length, same for all particles          [in]
c     x         : Coordinates of all particles                      [in]
c     niac      : Number of interaction pairs                      [out]
c     pair_i    : List of first partner of interaction pair        [out]
c     pair_j    : List of second partner of interaction pair       [out]
c     w         : Kernel for all interaction pairs                 [out]
c     dwdx      : Derivative of kernel with respect to x, y and z  [out]
c     countiac  : Number of neighboring particles                  [out]

      use param
      implicit none
C      include 'param.inc'

c     Parameter used for sorting grid cells in the link list algorithm
c     maxngx  : Maximum number of sorting grid cells in x-direction
c     maxngy  : Maximum number of sorting grid cells in y-direction
c     maxngz  : Maximum number of sorting grid cells in z-direction
c     Determining maximum number of sorting grid cells:
c     (For an homogeneous particle distribution:)
c     1-dim. problem: maxngx = maxn ,  maxngy = maxngz = 1
c     2-dim. problem: maxngx = maxngy ~ sqrt(maxn) ,  maxngz = 1
c     3-dim. problem: maxngx = maxngy = maxngz ~ maxn^(1/3)
      integer maxngx,maxngy,maxngz
      parameter ( maxngx  = 100        ,
     &            maxngy  = 100        ,
     &            maxngz  = 1          )      
      integer itimestep, ntotal, niac, pair_i(max_interaction),
     &        pair_j(max_interaction), countiac(maxn)
      double precision hsml, x(dim,maxn),w(max_interaction),
     &       dwdx(dim,max_interaction)
      integer i, j, d, scale_k, sumiac, maxiac, noiac, miniac, maxp,minp    
      integer grid(maxngx,maxngy,maxngz),xgcell(3,maxn),gcell(3),
     &     xcell,ycell,zcell,celldata(maxn),minxcell(3),maxxcell(3),
     &     dnxgcell(dim),dpxgcell(dim),ngridx(dim),ghsmlx(dim)
      double precision hsml2,dr,r,dx(dim),mingridx(dim),maxgridx(dim),
     &       tdwdx(dim), dgeomx(dim)

      if (skf.eq.1) then 
        scale_k = 2 
      else if (skf.eq.2) then 
        scale_k = 3 
      else if (skf.eq.3) then 
         scale_k = 3 
      endif 
     
      do i=1,ntotal
        countiac(i) = 0
      enddo

c     Initialize grid:  

      call init_grid(ntotal,hsml,grid,ngridx,ghsmlx,
     &     maxgridx,mingridx,dgeomx)
      
c     Position particles on grid and create linked list:
      
      do i=1,ntotal
        call grid_geom(i,x(1,i),ngridx,maxgridx,mingridx,dgeomx,gcell)
        do d=1,dim
          xgcell(d,i) = gcell(d)
        enddo
        celldata(i) = grid(gcell(1),gcell(2),gcell(3))
        grid(gcell(1),gcell(2),gcell(3)) = i
      enddo

c     Determine interaction parameters:

      niac = 0
      do i=1,ntotal-1

c     Determine range of grid to go through:
         
        do d=1,3
          minxcell(d) = 1
          maxxcell(d) = 1
        enddo
        do d=1,dim
          dnxgcell(d) = xgcell(d,i) - ghsmlx(d)
          dpxgcell(d) = xgcell(d,i) + ghsmlx(d)
          minxcell(d) = max(dnxgcell(d),1)
          maxxcell(d) = min(dpxgcell(d),ngridx(d))
        enddo

c     Search grid:
      
        do zcell=minxcell(3),maxxcell(3)
          do ycell=minxcell(2),maxxcell(2)
            do xcell=minxcell(1),maxxcell(1)
              j = grid(xcell,ycell,zcell)
 1            if (j.gt.i) then
                dx(1) = x(1,i) - x(1,j)
                dr    = dx(1)*dx(1)
                do d=2,dim
                  dx(d) = x(d,i) - x(d,j)
                  dr    = dr + dx(d)*dx(d)
                enddo
                if (sqrt(dr).lt.scale_k*hsml) then
                  if (niac.lt.max_interaction) then

c     Neighboring pair list, and totalinteraction number and
c     the interaction number for each particle 

                    niac = niac + 1
                    pair_i(niac) = i
                    pair_j(niac) = j
                    r = sqrt(dr)
                    countiac(i) = countiac(i) + 1
                    countiac(j) = countiac(j) + 1
                           
C--- Kernel and derivations of kernel

                    call kernel(r,dx,hsml,w(niac),tdwdx)
	            do d = 1, dim
	              dwdx(d,niac)=tdwdx(d)
                    enddo                  
                  else
                    print *,
     &              ' >>> Error <<< : too many interactions'
                    stop
                  endif
                endif
                j = celldata(j)
                goto 1
              endif
            enddo
          enddo
        enddo
      enddo

c     Statistics for the interaction

      sumiac = 0
      maxiac = 0
      miniac = 1000
      noiac  = 0
      do i=1,ntotal
        sumiac = sumiac + countiac(i)
        if (countiac(i).gt.maxiac) then
	  maxiac = countiac(i)
	  maxp = i
	endif
	if (countiac(i).lt.miniac) then 
	  miniac = countiac(i)
          minp = i
	endif
        if (countiac(i).eq.0)      noiac  = noiac + 1
      enddo
 
      if (mod(itimestep,print_step).eq.0) then
        if (int_stat) then
          print *,' >> Statistics: interactions per particle:'
          print *,'**** Particle:',maxp, ' maximal interactions:',maxiac
          print *,'**** Particle:',minp, ' minimal interactions:',miniac
          print *,'**** Average :',real(sumiac)/real(ntotal)
          print *,'**** Total pairs : ',niac
          print *,'**** Particles with no interactions:',noiac
        endif     
      endif

      end
      subroutine output
      
c----------------------------------------------------------------------           
c     Subroutine for saving particle information to external disk file

c     x-- coordinates of particles                                  [in]
c     vx-- velocities of particles                                  [in]
c     mass-- mass of particles                                      [in]
c     rho-- dnesities of particles                                  [in]
c     p-- pressure  of particles                                    [in]
c     u-- internal energy of particles                              [in]
c     c-- sound velocity of particles                               [in]
c     itype-- types of particles                                    [in]
c     hsml-- smoothing lengths of particles                         [in]
c     ntotal-- total particle number                                [in]

      use param
      use declarations_sph
      implicit none     
      
      integer, pointer, dimension(:) :: itype
      double precision, pointer, dimension(:,:) :: x
      double precision, pointer, dimension(:) :: mass,hsml,p

      integer ntotal, ntotal2
      integer i, d, npart, i1, i2, f1, f2, f3     

      ntotal =  parts%ntotal+parts%nvirt
      ntotal2=  soil%ntotal+soil%nvirt
     
      itype  => parts%itype
      x      => parts%x
      mass   => parts%mass
      hsml   => parts%hsml
      p      => parts%p

      write(f_xv,*) 'VARIABLES="X","Y","Pressure", "VoF",     
     & "vx","vy", "rho","zone" '
      write(f_xv,*) 'ZONE I=', ntotal, ' F=BLOCK'
 
      write(f_xv,*) x(1,1:ntotal) !, soil%x(1,1:ntotal2)
      write(f_xv,*) x(2,1:ntotal) !, soil%x(2,1:ntotal2)
c      write(f_xv,*) vx(1,1:ntotal)
c      write(f_xv,*) vx(2,1:ntotal)
!      write(f_xv,*) parts%dvx(1,1:ntotal)
!      write(f_xv,*) parts%dvx(2,1:ntotal)
c      write(f_xv,*) mass(1:ntotal)
      write(f_xv,*) p(1:ntotal) !, soil%p(1:ntotal2)
      write(f_xv,*) parts%vof(1:ntotal)
c      write(f_xv,*) u(1:ntotal)
c      write(f_xv,*) itype(1:ntotal)
c      write(f_xv,*) hsml(1:ntotal)                                        
      write(f_xv,*) parts%vx(1,1:ntotal)
      write(f_xv,*) parts%vx(2,1:ntotal)
      write(f_xv,*) parts%rho(1:ntotal)
      write(f_xv,*) parts%zone(1:ntotal)

      !return

      write(f_state,*) 'VARIABLES="X","Y","Pressure", "VoF", "ep", 
     & "sxy", "sxx","syy","vx","vy", "rho" '
      write(f_state,*) 'ZONE I=', ntotal2, ' F=BLOCK'
 
      write(f_state,*)  soil%x(1,1:ntotal2)
      write(f_state,*)  soil%x(2,1:ntotal2)
c      write(f_xv,*) vx(1,1:ntotal)
c      write(f_xv,*) vx(2,1:ntotal)
!      write(f_xv,*) parts%dvx(1,1:ntotal)
!      write(f_xv,*) parts%dvx(2,1:ntotal)
c      write(f_xv,*) mass(1:ntotal)
      write(f_state,*)  soil%p(1:ntotal2)
c      write(f_state,*)  soil%fail(1:ntotal2)
      write(f_state,*)  soil%vof(1:ntotal2)
      write(f_state,*)  soil%epsilon_p(1:ntotal2)
      write(f_state,*)  soil%sxy(1:ntotal2)
      write(f_state,*)  soil%sxx(1:ntotal2)
      write(f_state,*)  soil%syy(1:ntotal2)
      write(f_state,*)  soil%vx(1,1:ntotal2)
      write(f_state,*)  soil%vx(2,1:ntotal2)
      write(f_state,*)  soil%rho(1:ntotal2)

      return
      end subroutine

c---------------------------------------------------------
c     Including file for parameters and constants used 
c     in the entire SPH software packages.
c---------------------------------------------------------
      module param
c---------------------------------------------------------
      implicit none

c     dim : Dimension of the problem (1, 2 or 3)
      integer dim
      parameter ( dim = 2)

c     maxn    : Maximum number of particles
c     max_interation : Maximum number of interaction pairs
      integer maxn,max_interaction
      parameter ( maxn    = 12000    ,                  ! 12000
     &            max_interaction = 100 * maxn )

c     Parameters for the computational geometry,  
c     x_maxgeom : Upper limit of allowed x-regime 
c     x_mingeom : Lower limit of allowed x-regime 
c     y_maxgeom : Upper limit of allowed y-regime 
c     y_mingeom : Lower limit of allowed y-regime 
c     z_maxgeom : Upper limit of allowed z-regime 
c     z_mingeom : Lower limit of allowed z-regime 
      double precision x_maxgeom,x_mingeom,y_maxgeom,
     &                 y_mingeom,z_maxgeom,z_mingeom
      parameter ( x_maxgeom =  10.e0     ,
     &            x_mingeom = -10.e0     ,
     &            y_maxgeom =  10.e0     ,
     &            y_mingeom = -10.e0     ,
     &            z_maxgeom =  10.e0     ,
     &            z_mingeom = -10.e0     )
    
c     SPH algorithm for particle approximation (pa_sph)
c     pa_sph = 1 : (e.g. (p(i)+p(j))/(rho(i)*rho(j))
c              2 : (e.g. (p(i)/rho(i)**2+p(j)/rho(j)**2)
      integer pa_sph 
      parameter(pa_sph = 2)

c     Nearest neighbor particle searching (nnps) method
c     nnps = 1 : Simplest and direct searching
c            2 : Sorting grid linked list
c            3 : Tree algorithm
      integer nnps 
      parameter(nnps = 1 )

c     Smoothing length evolution (sle) algorithm
c     sle = 0 : Keep unchanged,
c           1 : h = fac * (m/rho)^(1/dim)
c           2 : dh/dt = (-1/dim)*(h/rho)*(drho/dt)
c           3 : Other approaches (e.g. h = h_0 * (rho_0/rho)**(1/dim) ) 

      integer sle 
      parameter(sle = 0)

c     Smoothing kernel function 
c     skf = 1, cubic spline kernel by W4 - Spline (Monaghan 1985)
c         = 2, Gauss kernel   (Gingold and Monaghan 1981) 
c         = 3, Quintic kernel (Morris 1997)
      integer skf 
      parameter(skf = 1)

c     Switches for different senarios

c     summation_density = .TRUE. : Use density summation model in the code, 
c                        .FALSE.: Use continuiity equation
c     average_velocity = .TRUE. : Monaghan treatment on average velocity,
c                       .FALSE.: No average treatment.
c     config_input = .TRUE. : Load initial configuration data,
c                   .FALSE.: Generate initial configuration.
c     virtual_part = .TRUE. : Use vritual particle,
c                   .FALSE.: No use of vritual particle.
c     vp_input = .TRUE. : Load virtual particle information,
c               .FALSE.: Generate virtual particle information.
c     visc = .true. : Consider viscosity,
c           .false.: No viscosity.
c     ex_force =.true. : Consider external force,
c               .false.: No external force.
c     visc_artificial = .true. : Consider artificial viscosity,
c                      .false.: No considering of artificial viscosity.
c     heat_artificial = .true. : Consider artificial heating,
c                      .false.: No considering of artificial heating.
c     self_gravity = .true. : Considering self_gravity,
c                    .false.: No considering of self_gravity
c     nor_density =  .true. : Density normalization by using CSPM,
c                    .false.: No normalization.
      logical summation_density, average_velocity, config_input,
     &        virtual_part, vp_input, visc, ex_force, heat_artificial,
     &        visc_artificial, self_gravity, nor_density
      parameter ( summation_density  = .false. )       !
      parameter ( average_velocity  = .false. )       !
      parameter ( config_input  = .false. )
      parameter ( virtual_part  = .true. )
      parameter ( vp_input  = .false.  )
      parameter ( visc  = .true.  )
      parameter ( ex_force  = .true.)
      parameter ( visc_artificial  = .true. )         !
      parameter ( heat_artificial  = .false. )
      parameter ( self_gravity  = .true. )      
      parameter ( nor_density  = .false. )             !

      integer stress_integration
      parameter ( stress_integration = 2)
      integer yield_criterion
      parameter ( yield_criterion = 2)
      logical plasticity
      parameter ( plasticity = .true. )
      logical artificial_density                  ! not used at the moment
      parameter (artificial_density = .true.)
      logical soil_artificial_stress
      parameter (soil_artificial_stress = .true.)
      logical water_tension_instability
      parameter (water_tension_instability = .false.)

c     Symmetry of the problem
c     nsym = 0 : no symmetry,
c          = 1 : axis symmetry,
c          = 2 : center symmetry.     
      integer    nsym
      parameter ( nsym = 0)

c     Control parameters for output 
c     int_stat = .true. : Print statistics about SPH particle interactions.
c                        including virtual particle information.
c     print_step: Print Timestep (On Screen)
c     save_step : Save Timestep    (To Disk File)
c     moni_particle: The particle number for information monitoring.
      logical int_stat
      parameter ( int_stat = .true. )
      integer print_step, save_step, moni_particle
      parameter ( !print_step = 20,
     &            !save_step = 20,
     &            moni_particle = 264   )
           
      double precision pi,gravity
      parameter ( pi = 3.14159265358979323846 )
      parameter ( gravity = -9.8 )
      
c     Simulation cases
c     shocktube = .true. : carry out shock tube simulation
c     shearcavity = .true. : carry out shear cavity simulation
      logical shocktube, shearcavity, waterjet
      parameter ( shocktube  = .false. )
      parameter ( shearcavity  = .false. )
      parameter ( waterjet = .true.)

!     Recorde time interval
      integer save_step_from, save_step_to
      parameter (save_step_from = 0, save_step_to = 100)

      end module
      subroutine single_step
c----------------------------------------------------------------------
c   Subroutine to determine the right hand side of a differential 
c   equation in a single step for performing time integration 

c   In this routine and its subroutines the SPH algorithms are performed.
c     itimestep: Current timestep number                            [in]
c     dt       : Timestep                                           [in]
c     ntotal   :  Number of particles                               [in]
c     hsml     :  Smoothing Length                                  [in]
c     mass     :  Particle masses                                   [in]
c     x        :  Particle position                                 [in]
c     vx       :  Particle velocity                                 [in]
c     u        :  Particle internal energy                          [in]
c     s        :  Particle entropy (not used here)                  [in]
c     rho      :  Density                                       [in/out]
c     p        :  Pressure                                         [out]
c     t        :  Temperature                                   [in/out]
c     tdsdt    :  Production of viscous entropy t*ds/dt            [out]
c     dx       :  dx = vx = dx/dt                                  [out]
c     dvx      :  dvx = dvx/dt, force per unit mass                [out]
c     du       :  du  = du/dt                                      [out]
c     ds       :  ds  = ds/dt                                      [out]     
c     drho     :  drho =  drho/dt                                  [out]
c     itype    :  Type of particle                                 [in]
c     av       :  Monaghan average velocity                        [out]

      use param
      use declarations_sph
      implicit none

      integer  nphase, iphase
      type(particles), pointer :: pl
      logical :: dbg = .false.
                 
      if(dbg) write(*,*) 'In single_step...'

                                      nphase = 2
                                      if(single_phase) nphase=1

                                      do iphase = 1, nphase
                                         if(iphase==1) pl => parts
                                         if(iphase==2) pl => soil 

      pl%dvx = 0.d0; pl%drho = 0.d0
      pl%dsxx = 0.d0; pl%dsxy = 0.d0; pl%dsyy = 0.d0
      if(trim(pl%imaterial)=='soil') pl%dp = 0.d0
      if(trim(pl%imaterial)=='water') pl%dvof = 0.d0

      !if(iphase==2)exit
     
c---  Positions of virtual (boundary) particles: 

!      if (virtual_part) call virt_part
 
c---  Interaction parameters, calculating neighboring particles
c     and optimzing smoothing length
  
      if (nnps.eq.1) then 
        call direct_find(pl)
      else if (nnps.eq.2) then
!        call link_list(itimestep, ntotal+nvirt,hsml(1),x,niac,pair_i,
!     &       pair_j,w,dwdx,ns)
!        call link_list(itimestep, parts%ntotal+parts%nvirt,
!     &       parts%hsml(1),parts%x,parts%niac,parts%pair_i,
!     &       parts%pair_j,parts%w,parts%dwdx,parts%countiac)
      else if (nnps.eq.3) then 
c        call tree_search(itimestep, ntotal+nvirt,hsml,x,niac,pair_i,
c     &       pair_j,w,dwdx,ns)
      endif         

      if(mod(itimestep,print_step).eq.0.and.int_stat) then
         call pl%interaction_statistics
      endif   

c---  Density approximation or change rate
     
      if (summation_density) then      
         call sum_density(pl)
      else             
         call con_density(pl)         
      endif

      !if(trim(pl%imaterial)=='water')then
         !call renormalize_density_gradient(pl)
         call art_density(pl)
      !endif

c---  Dynamic viscosity:

      if(trim(pl%imaterial)=='water')then
         if (visc) call viscosity(pl)
      elseif(trim(pl%imaterial)=='soil')then
         call shear_modulus(pl)
      endif
       
c---  Internal forces:

      call shear_strain_rate(pl)   
      if(trim(pl%imaterial)=='soil')call velocity_divergence(pl)

      call pressure(pl)

      if(trim(pl%imaterial)=='water')then
         call newtonian_fluid(pl)
      elseif(trim(pl%imaterial)=='soil')then

         if(yield_criterion == 1)then
            call mohr_coulomb_failure_criterion(pl)
         elseif(yield_criterion == 2)then
            !call drucker_prager_failure_criterion(pl)
         endif

         if(mod(itimestep,print_step).eq.0)                        
     *       write(*,*) 'Failured points: ', pl%nfail
      endif

      call int_force(pl) 
      !write(*,*) parts%dvx(1,1:10), parts%dvx(2,1:10)
       
      if(trim(pl%imaterial)=='water')
     &   call tension_instability(pl) 

! --- Plasticity flow rule   ! This was done before Jaummann_rate, because we 
!     we need txx,tyy,tzz, which was destroyed in Jaumann_rate!

      if(trim(pl%imaterial)=='soil'.and.plasticity) 
     &   call plastic_flow_rule(pl)

c --- Jaumann rate  !When???

      if(trim(pl%imaterial)=='soil') call Jaumann_rate(pl)

c---  Artificial viscosity:

      if (visc_artificial) call art_visc(pl)

      if(trim(pl%imaterial)=='soil'.and.soil_artificial_stress) 
     &   call art_stress(pl)
      if(trim(pl%imaterial)=='water')
     &   call art_volume_fraction_water2(pl)
     
c---  External forces:

      if (ex_force) call ext_force(pl)
      !write(*,*) parts%dvx(1,1:10), parts%dvx(2,1:10)

c     Calculating the neighboring particles and undating HSML
      
      if (sle.ne.0) call h_upgrade(pl)

c      if (heat_artificial) call art_heat(ntotal+nvirt,hsml,
c     &         mass,x,vx,niac,rho,u, c,pair_i,pair_j,w,dwdx,ahdudt)
     
c     Calculating average velocity of each partile for avoiding penetration

      if (average_velocity) call av_vel(pl) 

c---  Convert velocity, force, and energy to f and dfdt  
      
      if(mod(itimestep,print_step).eq.0) then     
!          call pl%particle_monitor
           call pl%minimum_time_step  
      endif

                                            enddo ! iphase

                if(.not.single_phase)then

!-------------------Water/soil interaction-------------------------------

c---  Interaction parameters, calculating neighboring particles
c     and optimzing smoothing length
  
      if (nnps.eq.1) then 
         call direct_find_2(parts,soil)
        !call direct_find(parts)
      else if (nnps.eq.2) then
c        call link_list(itimestep, ntotal+nvirt,hsml(1),x,niac,pair_i,
c     &       pair_j,w,dwdx,ns)
      else if (nnps.eq.3) then 
c        call tree_search(itimestep, ntotal+nvirt,hsml,x,niac,pair_i,
c     &       pair_j,w,dwdx,ns)
      endif         

      if(mod(itimestep,print_step).eq.0.and.int_stat) then
         call parts%interaction_statistics
      endif    

      call darcy_law(parts,soil)          !!! To be corrected!
      call pore_water_pressure(parts,soil) 
      !write(*,*) soil%dvx(1,1:10), soil%dvx(2,1:10)

      call volume_fraction_soil(soil)
      call volume_fraction_water2(parts,soil)

!      call direct_find(parts) 
!      call art_volume_fraction_water2(parts)
     
             endif ! .not.single_phase

      if(itimestep>=save_step_from.and.
     &   mod(itimestep,save_step).eq.0)then
         call output
      endif 

      return
      end subroutine
c	      program SPH
              subroutine beham

c----------------------------------------------------------------------
c     This is a three dimensional SPH code. the followings are the 
c     basic parameters needed in this codeor calculated by this code

c     mass-- mass of particles                                      [in]
c     ntotal-- total particle number ues                            [in]
c     dt--- Time step used in the time integration                  [in]
c     itype-- types of particles                                    [in]
c     x-- coordinates of particles                              [in/out]
c     vx-- velocities of particles                              [in/out]
c     rho-- dnesities of particles                              [in/out]
c     p-- pressure  of particles                                [in/out]
c     u-- internal energy of particles                          [in/out]
c     hsml-- smoothing lengths of particles                     [in/out]
c     c-- sound velocity of particles                              [out]
c     s-- entropy of particles                                     [out]
c     e-- total energy of particles                                [out]

      use constants
      use param
      use declarations
      use declarations_sph
      implicit none     
c
      integer d, m, i, yesorno
      double precision s1, s2
c
      call time_print
      call time_elapsed(s1)

      call open_files      

      call allocate_sph

      if (shocktube)   dt = 0.005
      if (shearcavity) dt = 5.e-5
      !if (waterjet)    dt = 0.0001    !single_phase
      !if (waterjet)    dt = 0.00001   !two_phase

      call input
      call output

      call parts%minimum_time_step

 1    write(*,*)'  ***************************************************' 
      write(*,*)'          Please input the maximal time steps '
      write(*,*)'  ***************************************************'
      read(*,*) maxtimestep      

      call time_integration

      call time_elapsed(s2)

      write (*,*)'        Elapsed CPU time = ', s2-s1
      s1 = s2

      write(*,*)'  ***************************************************'
      write(*,*) 'Are you going to run more time steps ? (0=No, 1=yes)'
      write(*,*)'  ***************************************************'
      read (*,*) yesorno     
      if (yesorno.ne.0) go to 1

      call close_files 
  
      call time_print
      call time_elapsed(s2)

      write (*,*)'        Elapsed CPU time = ', s2-s1
                           
      end
      subroutine time_integration
    
c----------------------------------------------------------------------
c      x-- coordinates of particles                       [input/output]
c      vx-- velocities of particles                       [input/output]
c      mass-- mass of particles                                  [input]
c      rho-- dnesities of particles                       [input/output]
c      p-- pressure  of particles                         [input/output]
c      u-- internal energy of particles                   [input/output]
c      c-- sound velocity of particles                          [output]
c      s-- entropy of particles, not used here                  [output]
c      e-- total energy of particles                            [output]
c      itype-- types of particles                               [input]
c           =1   ideal gas
c           =2   water
c           =3   tnt
c      hsml-- smoothing lengths of particles              [input/output]
c      ntotal-- total particle number                            [input]  
c      maxtimestep-- maximum timesteps                           [input]
c      dt-- timestep                                             [input]

      use param
      use declarations_sph
      implicit none     
c  
      double precision, pointer, dimension(:) :: rho, p, u, drho, du
      double precision, pointer, dimension(:,:) :: x,vx,av,dvx 
c
      integer :: i, j, k, d, ntotal, it
      double precision :: temp_rho, temp_u
      type(particles), pointer :: pl

      ntotal = parts%ntotal
      x     => parts%x
      vx    => parts%vx
      rho   => parts%rho
      p     => parts%p
      u     => parts%u
      drho  => parts%drho
      dvx   => parts%dvx
      du    => parts%du
      av    => parts%av
              
      do it = 1, maxtimestep   
  
        itimestep = itimestep+1

        parts%itimestep = itimestep
        soil%itimestep  = itimestep

        if (mod(itimestep,print_step).eq.0) then
         write(*,*)'______________________________________________'
         write(*,*)'  current number of time step =',
     &           itimestep,'     current time=', real(time+dt)
         write(*,*)'______________________________________________'
        endif  
  
!--------------For water--------------------------------------------------
      
c     If not first time step, then update thermal energy, density and 
c     velocity half a time step  

        if (itimestep .ne. 1) then
           pl => parts
           call first_half

                             ! For soil
                             if(.not.single_phase)then
                                pl => soil
                                call first_half
c                              call drucker_prager_failure_criterion(pl)
                                !call volume_fraction_soil(soil)
                                !call volume_fraction_water(parts, soil)
                             endif  
        endif

c---  Definition of variables out of the function vector:    

        call single_step

        do i = 1, ntotal
           if(parts%zone(i)==1.and.x(2,i)>-wasserjet%immerse)then
              drho(i) = 0.
              du(i)   = 0.
              dvx(:,i)  = 0.
           endif
        enddo

        if (itimestep .eq. 1) then
           pl => parts
           call first_step
       
                                if(.not.single_phase)then
                                    pl => soil
                                    call first_step
                               call drucker_prager_failure_criterion(pl)
                                 !call volume_fraction_soil(soil)
                                 !call volume_fraction_water(parts, soil)
                                endif
        else
   
           pl => parts
           call second_half          

                                if(.not.single_phase)then
                                   pl => soil
                                   call second_half
                               call drucker_prager_failure_criterion(pl)
                                 !call volume_fraction_soil(soil)
                                 !call volume_fraction_water(parts, soil)
                                endif
        endif 


! For saturated flow

!        if(.not.single_phase)then
!           call volume_fraction_soil(soil)
!           call volume_fraction_water(parts, soil)
!        endif        

!--------------------Velocity Inlet-----------------------

!DEC$IF(.FALSE.)
        k = 0
        do i = 1,ntotal
           if(parts%zone(i)==1.and.x(2,i)<-wasserjet%immerse)then
              parts%zone(i) = 0
              k = k + 1
              x(1,ntotal+k) = x(1,i)
              x(2,ntotal+k) = x(2,i)+parts%hsml(i)
              parts%vol(ntotal+k) = parts%vol(i)
              parts%hsml(ntotal+k) = parts%hsml(i)
              parts%itype(ntotal+k) = 2
              vx(1,ntotal+k) = 0.
              vx(2,ntotal+k) = inlet_velocity
              parts%p(ntotal+k) = 0.
              rho(ntotal+k) = 1000.
              parts%mass(ntotal+k) = parts%vol(ntotal+k)*rho(ntotal+k)
              parts%zone(ntotal+k) = 1

              parts%dvx(:,ntotal+k) = 0.
              parts%du(ntotal+k)  = 0.
              parts%drho(ntotal+k)= 0.
           endif
        enddo
        parts%ntotal = parts%ntotal + k
        ntotal = parts%ntotal
!---------------------------------------------------------

!DEC$ENDIF
        time = time + dt

!	if (itimestep>=save_step_from.and.mod(itimestep,save_step).eq.0) then
!          call output
!	endif 

        if (mod(itimestep,print_step).eq.0) then
          write(*,*)
          write(*,101)'x','velocity', 'dvx'    
          write(*,100)x(1,moni_particle), vx(1,moni_particle), 
     &                dvx(1,moni_particle)    
        endif
        
101     format(1x,3(2x,a12))	 
100     format(1x,3(2x,e13.6))

      enddo

      return

c -------------------
      contains
c -------------------

      subroutine first_half
c ---------------------------------------------------------------------
      implicit none

      do i = 1, pl%ntotal+pl%nvirt    ! originally only pl%ntotal       
         pl%u_min(i) = pl%u(i)
         temp_u=0.
         !if (dim.eq.1) temp_u=-nsym*p(i)*vx(1,i)/x(1,i)/rho(i)
         pl%u(i) = pl%u(i) + (dt/2.)* (pl%du(i)+temp_u)
         if(pl%u(i).lt.0)  pl%u(i) = 0.                 
            
         if (.not.summation_density) then    
            pl%rho_min(i) = pl%rho(i)
            temp_rho=0.
            !if (dim.eq.1) temp_rho=-nsym*rho(i)*vx(1,i)/x(1,i)
            pl%rho(i) = pl%rho(i) +(dt/2.)*( pl%drho(i)+ temp_rho)
         endif

         if(trim(pl%imaterial)=='water')then
            pl%vof_min(i) = pl%vof(i)
            pl%vof(i) = pl%vof(i)+(dt/2.)*pl%dvof(i) 
         endif
 
         if(trim(pl%imaterial)=='soil')then
                  if(stress_integration==1)then
         !pl%sxx(i) = pl%sxx(i) + dt*pl%dsxx(i)
         !pl%sxy(i) = pl%sxy(i) + dt*pl%dsxy(i)
         !pl%syy(i) = pl%syy(i) + dt*pl%dsyy(i)
                  elseif(stress_integration==2)then
         pl%sxx_min(i) = pl%sxx(i)
         pl%sxy_min(i) = pl%sxy(i)
         pl%syy_min(i) = pl%syy(i)
         pl%p_min(i)   = pl%p(i)
         pl%sxx(i) = pl%sxx(i) + (dt/2.)*pl%dsxx(i)
         pl%sxy(i) = pl%sxy(i) + (dt/2.)*pl%dsxy(i)
         pl%syy(i) = pl%syy(i) + (dt/2.)*pl%dsyy(i)
         pl%p(i) = pl%p(i) + (dt/2.)*pl%dp(i)
                  endif
         endif
          
         if(pl%itype(i)<0)cycle
         do d = 1, dim
            pl%v_min(d, i) = pl%vx(d, i)
            pl%vx(d, i) = pl%vx(d, i) + (dt/2.)*pl%dvx(d, i)
         enddo
      enddo
 
      return
      end subroutine

      subroutine first_step
c -------------------------------------------------------------------
      implicit none

      do i=1,pl%ntotal+pl%nvirt     ! origionally pl%ntotal
         temp_u=0.
         !if (dim.eq.1) temp_u=-nsym*p(i)*vx(1,i)/x(1,i)/rho(i)        
         pl%u(i) = pl%u(i) + (dt/2.)*(pl%du(i) + temp_u)
         if(pl%u(i).lt.0)  pl%u(i) = 0.             
         
         if (.not.summation_density ) then
            temp_rho=0.
            !if (dim.eq.1) temp_rho=-nsym*rho(i)*vx(1,i)/x(1,i)
            pl%rho(i) = pl%rho(i) + (dt/2.)* (pl%drho(i)+temp_rho)
         endif

         if(trim(pl%imaterial)=='water')then
            pl%vof(i) = pl%vof(i)+(dt/2.)*pl%dvof(i)
         endif

         if(trim(pl%imaterial)=='soil')then
                  if(stress_integration==1)then
         pl%sxx(i) = pl%sxx(i) + dt*pl%dsxx(i)
         pl%sxy(i) = pl%sxy(i) + dt*pl%dsxy(i)
         pl%syy(i) = pl%syy(i) + dt*pl%dsyy(i)
                  elseif(stress_integration==2)then
         pl%sxx(i) = pl%sxx(i) + (dt/2.)*pl%dsxx(i)
         pl%sxy(i) = pl%sxy(i) + (dt/2.)*pl%dsxy(i)
         pl%syy(i) = pl%syy(i) + (dt/2.)*pl%dsyy(i)
         pl%p(i)   = pl%p(i) + (dt/2.)*pl%dp(i)
                  endif
         endif
        
         if(pl%itype(i)<0)cycle
         do d = 1, dim        
            pl%vx(d, i) = pl%vx(d, i) + (dt/2.) * pl%dvx(d, i) 
     &                  + pl%av(d, i)
            pl%x(d, i) = pl%x(d, i) + dt * pl%vx(d, i)
         enddo           
      enddo 
      
      return
      end subroutine

      subroutine second_half
c ------------------------------------------------------------------
      implicit none

      do i=1,pl%ntotal+pl%nvirt  ! origionally pl%ntotal            
         temp_u=0.
         !if (dim.eq.1) temp_u=-nsym*p(i)*vx(1,i)/x(1,i)/rho(i)                       
         pl%u(i) = pl%u_min(i) + dt*(pl%du(i)+temp_u)
         if(pl%u(i).lt.0)  pl%u(i) = 0.          
            
         if (.not.summation_density ) then 
            temp_rho=0.
            !if (dim.eq.1) temp_rho=-nsym*rho(i)*vx(1,i)/x(1,i)        	           
            pl%rho(i) = pl%rho_min(i) + dt*(pl%drho(i)+temp_rho)
         endif

         if(trim(pl%imaterial)=='water')then
            pl%vof(i) = pl%vof_min(i)+dt*pl%dvof(i) 
         endif
                 
         if(trim(pl%imaterial)=='soil')then 
                  if(stress_integration==1)then 
         pl%sxx(i) = pl%sxx(i) + dt*pl%dsxx(i)
         pl%sxy(i) = pl%sxy(i) + dt*pl%dsxy(i)
         pl%syy(i) = pl%syy(i) + dt*pl%dsyy(i)
                  elseif(stress_integration==2)then
         pl%sxx(i) = pl%sxx_min(i) + dt*pl%dsxx(i)
         pl%sxy(i) = pl%sxy_min(i) + dt*pl%dsxy(i)
         pl%syy(i) = pl%syy_min(i) + dt*pl%dsyy(i)
         pl%p(i)   = pl%p_min(i) + dt*pl%dp(i)
                  endif
         endif

         if(pl%itype(i)<0)cycle
         do d = 1, dim                   
            pl%vx(d, i) = pl%v_min(d, i) + dt * pl%dvx(d, i) 
     &                  + pl%av(d, i)
            pl%x(d, i) = pl%x(d, i) + dt * pl%vx(d, i)                  
         enddo
      enddo

      return
      end subroutine

      end subroutine
C     ****************************
      subroutine usr_def_parameter
C     ****************************
     * (pname, pvalu, ncoma)
C ----------------------------------------------------------
C  Version 1.0 June. 01, 2010, Chun WANG (SJTU) 34204490
C ----------------------------------------------------------
C  Function: assignment via internal file
C ----------------------------------------------------------
      use constants
      use declarations
      use param
      use declarations_sph
C
      implicit none
C
      character(len=*)   :: pname, pvalu
      integer(kind=ik_3)  :: ncoma, ndim, i
C
      pname = adjustl(pname)
      pvalu = adjustl(pvalu)
C     
 
      call make_upper(pname)
C            
      select case (trim(adjustl(pname)))
C
C This part can be modified by the users!
C
C For example:
C
      case('PRINT STEP')

          read(pvalu,*) print_step
          write(*,*) 'Print step = ', print_step

      case('SAVE STEP')

          read(pvalu,*) save_step
          write(*,*) 'Save step = ', save_step

      case('RESULTS FILE')
                
                  !ndim = 1
                  !if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
                  read(pvalu,*) results, res_soil
            write(*,*) 'Results file = ', trim(results), '  ',
     &                                    trim(res_soil)

      case('INLET VELOCITY')

         read(pvalu,*) inlet_velocity
         write(*,*) 'Inlet velocity = ', inlet_velocity

      case('SINGLE PHASE')
                
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
                  read(pvalu,*) single_phase
                  write(*,*) 'Single phase = ', single_phase

      case('FIRST PHASE')

                  read(pvalu,*) parts%imaterial
                  write(*,*) 'First phase = ', parts%imaterial

      case('SECOND PHASE')

                  read(pvalu,*) soil%imaterial
                  write(*,*) 'Second phase = ', soil%imaterial

      case('DRY SOIL')

                  read(pvalu,*) dry_soil
                  write(*,*) 'Dry soil = ', dry_soil

      case('PARTICLE SIZE')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
                  read(pvalu,*) particle_size
                  write(*,*) 'Particle size = ', particle_size

       case('IMMERSE DEPTH')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
                  read(pvalu,*) wasserjet%immerse
                  write(*,*) 'Immerse depth = ', wasserjet%immerse

       case('WITH NOZZLE')
                  
                  read(pvalu,*) with_nozzle
                  write(*,*) 'With nozzle = ', with_nozzle

      case('WATER PROPERTY')

          read(pvalu,*) h2o%rho0,h2o%b,h2o%gamma, h2o%c, h2o%viscosity
          write(*,*) 'Water property: rho0, b, gamma, c, viscosity' 
          write(*,*) h2o%rho0, h2o%b, h2o%gamma, h2o%c, h2o%viscosity

      case('SOIL PROPERTY')

          read(pvalu,*) sio2%rho0, sio2%k, sio2%E, sio2%niu, sio2%c
          write(*,*) 'Soil property: rho0, k, Youngs, Poisson, c' 
          write(*,*) sio2%rho0, sio2%k, sio2%E, sio2%niu, sio2%c

      case('DARCY PARAMETER')

          read(pvalu,*) sio2%porosity, sio2%permeability
          write(*,*) 'Darcy parameter: porosity, permeability '
          write(*,*) sio2%porosity, sio2%permeability

      case('SOIL FAILURE CRITERIA')
       
          read(pvalu,*) sio2%cohesion, SIO2%phi
          write(*,*) 'Soil failure criteria: cohesion, phi'
          write(*,*) sio2%cohesion, sio2%phi

      case('DYNAMIC VISCOSITY')
  
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) miu
!                  write(*,*) 'Dynamic viscosity =', miu

      case('MAXIMUM ITERATION NUMBER')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) cfg%ITMAX
!                  write(*,*) 'Maximum iteration number = ', cfg%ITMAX

      case('DENSITY')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) rho
!                  write(*,*) 'Density = ', rho
                
      case('TOLERANCE')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) cfg%tol
!                  write(*,*) 'Tolerance = ', cfg%tol

      case('RELAXATION FACTOR FOR VELOCITY')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) rfu
!                  write(*,*) 'Relaxation factor for velocity = ', rfu

      case('RELAXATION FACTOR FOR PRESSURE')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) rfp
!                  write(*,*) 'Relaxation factor for pressure = ',rfp

      case('STEADY')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) steady
!                  write(*,*) 'Steady = ',steady
      case('TIME STEP SIZE')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
                  read(pvalu,*) dt
                  write(*,*) 'Time step size = ', dt
      case('MAXIMUM TIME STEP')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) max_time_step
!                  write(*,*) 'Maximum time step = ', max_time_step


      case('BUOYANCY')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) buoyancy
!                  write(*,*) 'Buoyancy = ', buoyancy

      case('RELAXATION FACTOR FOR TEMPERATURE')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,*) rft
!                  write(*,*) 'Relaxation factor for temperature = ', rft

      case('PRESSURE REFERENCE POINT')
                  
!                  read(pvalu,*) ref_pnt%x, ref_pnt%y 
!                  write(*,*) 'Pressure reference point: ', ref_pnt%x, 
!     *                                                     ref_pnt%y
      case('SOLVER')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,'(A)') cfg%solver
!                  write(*,*) 'Solver = ', cfg%solver

      case('PRECONDITION')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,'(A)') cfg%precon
!                  write(*,*) 'Precondition = ', cfg%precon

      case('CONVECTION SCHEME')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,'(A)') convection_scheme
!                  write(*,*) 'Convection scheme = ', convection_scheme

       case('MATRIX STORAGE')
                  ndim = 1
                  if(ncoma>=ndim) call trim_pvalu(trim(pvalu),',',ndim)
!                  read(pvalu,'(A)') matrix_storage
!                  write(*,*) 'Matrix storage = ', matrix_storage

      case DEFAULT

                 write(*,*) "Error: No such keyword -- ", pname

      end select
C          

      return
      end


       subroutine virt_part

c----------------------------------------------------------------------
c   Subroutine to determine the information of virtual particles
c   Here only the Monaghan type virtual particles for the 2D shear
c   cavity driven problem are generated.
c     itimestep : Current time step                                 [in]
c     ntotal : Number of particles                                  [in]
c     nvirt  : Number of virtual particles                         [out]
c     hsml   : Smoothing Length                                 [in|out]
c     mass   : Particle masses                                  [in|out]
c     x      : Coordinates of all particles                     [in|out]
c     vx     : Velocities of all particles                      [in|out]
c     rho    : Density                                          [in|out]
c     u      : internal energy                                  [in|out]
c     itype   : type of particles                               [in|out]

      use param
      use declarations_sph
      implicit none

      double precision, pointer, dimension(:) :: mass, vol, rho, p, u
      double precision, pointer, dimension(:,:) :: x, vx

      integer i, j, d, im, mp, n1, n2
      double precision xl, dx, v_inf, pore_water_pressure
      double precision, external :: rho_initial, rho_soil_initial

      x    => parts%x
      vol  => parts%vol
      mass => parts%mass
      vx   => parts%vx
      rho  => parts%rho
      p    => parts%p
      u    => parts%u

      if (vp_input) then          
                        
c        open(xv_vp,file="../../data/xv_vp.dat")
c        open(state_vp,file="../../data/state_vp.dat")
c        open(other_vp,file="../../data/other_vp.dat")            
c        read(xv_vp,*) nvirt
c        do j = 1, nvirt   
c          i = ntotal + j      
c          read(xv_vp,*)im, (x(d, i),d = 1, dim), (vx(d, i),d = 1, dim)                     
c          read(state_vp,*)im, mass(i), rho(i), p(i), u(i)        
c          read(other_vp,*)im, itype(i), hsml(i)                            
c        enddo  
c        close(xv_vp)
c        close(state_vp) 
c        close(other_vp) 
      
      else 
       
!        call parts%append_virtual_particles 
    
!        n1 = parts%ntotal+1
!        n2 = parts%ntotal+parts%nvirt

!        vx(1:2,n1:n2) = 0.
!        rho(n1:n2) = 1000.  !*0.3
!        p(n1:n2) = rho(n1:n2)*gravity*(x(2,n1:n2)+wasserjet%ds) !0.
!        u(n1:n2) = 357.1

!        do i = n1, n2
!           rho(i) = rho_initial(p(i))
!        enddo

       ! call initial_density(parts)
!        mass(n1:n2) = vol(n1:n2)*rho(n1:n2)
        

      endif   

c      if (mod(itimestep,save_step).eq.0) then
cc        open(1,file="../../data/xv_vp.dat")
cc        open(2,file="../../data/state_vp.dat")
cc        open(3,file="../../data/other_vp.dat")            
cc        write(1,*) nvirt
c        do i = ntotal + 1, ntotal + nvirt         
c         write(xv_vp,1001) i, (x(d, i), d=1,dim), (vx(d, i), d = 1, dim)              
c         write(state_vp,1002) i, mass(i), rho(i), p(i), u(i)
c         write(other_vp,1003) i, itype(i), hsml(i)                               
c        enddo       
c1001    format(1x, I6, 6(2x, e15.8))
c1002    format(1x, I6, 7(2x, e15.8)) 
c1003    format(1x, I6, 2x, I4, 2x, e15.8)
cc        close(1)
cc        close(2) 
cc        close(3) 
c      endif 

      if (mod(itimestep,print_step).eq.0) then
        if (int_stat) then
         print *,' >> Statistics: Virtual boundary particles:'
         print *,'          Number of virtual particles:',parts%NVIRT
        endif     
      endif

c
c For soil
c
        if (single_phase)return

!        call soil%append_virtual_particles
    
!        n1 = soil%ntotal+1
!        n2 = soil%ntotal+soil%nvirt

!        soil%vx(1:2,n1:n2) = 0.
!        soil%rho(n1:n2) = 2560.  !*0.7
     
!        do i = n1,n2
!          pore_water_pressure = 1000.*gravity*  !*0.3
!     &                    (soil%x(2,i)+wasserjet%ds)
!          !pore_water_pressure = 0.
!          soil%p(i) = -pore_water_pressure+soil%rho(i)*gravity*
!     &                    (soil%x(2,i)+wasserjet%ds) !0.
!        enddo

!        soil%u(n1:n2) = 357.1
!        !soil%st(n1:n2)%xx = 0.

!        do i = n1, n2
!           soil%rho(i) = rho_soil_initial(soil%p(i))
!        enddo
!        soil%mass(n1:n2) = soil%vol(n1:n2)*soil%rho(n1:n2)

      return
      end subroutine
      subroutine viscosity(parts)
c----------------------------------------------------------------------
c   Subroutine to define the fluid particle viscosity
 
c     ntotal  : Number of particles                                 [in]
c     itype    : Type of particle                                   [in]
c     x       : Coordinates of all particles                        [in]
c     rho     : Density                                             [in]
c     eta     : Dynamic viscosity                                  [out]

      use param
      use m_particles
      implicit none

      type(particles) parts

      integer ntotal,i
      integer, pointer, dimension(:) :: itype
      double precision, pointer, dimension(:) :: eta
      type(material), pointer :: liquid

      ntotal = parts%ntotal + parts%nvirt
      itype => parts%itype
      eta   => parts%eta
      liquid=> parts%material

      do i=1,ntotal
        if (abs(itype(i)).eq.1) then
          eta(i)=0.
        else if (abs(itype(i)).eq.2) then
          eta(i)=liquid%viscosity
        endif  
      enddo  
 
      return
      end subroutine

      subroutine shear_modulus(soil)
c-------------------------------------------------------------
      use m_particles
      implicit none

      type(particles) soil
      type(material), pointer :: property
      double precision e,v
      integer i

      property => soil%material

      e = property%E
      v = property%niu

      do i = 1, soil%ntotal+soil%nvirt
         if(abs(soil%itype(i))==3)then
            soil%eta(i) = e/(2.0*(1+v)) 
         endif
      enddo

      return
      end subroutine

!-------------------------------
     subroutine allocate_sph
!-------------------------------
use param
use declarations_sph
implicit none

!---------------------Real particles (water)---------------------
parts%dim  = dim
parts%maxn = maxn
parts%max_interaction = max_interaction

call allocate_particles(parts)

allocate(parts%zone(maxn)); parts%zone = 0

allocate(parts%w(max_interaction));             parts%w   = 0.d0
allocate(parts%dwdx(dim,max_interaction));      parts%dwdx= 0.d0
allocate(parts%pair_i(max_interaction));        parts%pair_i = 0
allocate(parts%pair_j(max_interaction));        parts%pair_j = 0
allocate(parts%countiac(maxn));                 parts%countiac=0

! Fields variables

call allocate_particles_fields(parts)

! Working arrays outside particles type

allocate(txx(maxn), tyy(maxn), txy(maxn))
txx = 0.d0; tyy = 0.d0; txy = 0.d0

parts%txx => txx; parts%tyy => tyy; parts%txy => txy

if(trim(parts%imaterial)=='water')then
   parts%sxx => txx; parts%syy => tyy; parts%sxy => txy
elseif(trim(parts%imaterial)=='soil')then
   parts%wxy => txy
endif   

! Material assignment

if(trim(parts%imaterial)=='water') parts%material => H2O
if(trim(parts%imaterial)=='soil')  parts%material => SiO2


!--------------- Soil particles --------------------------------

if(single_phase) return

soil%dim = dim
soil%maxn= maxn
soil%max_interaction = max_interaction

call allocate_particles(soil)

soil%w      => parts%w
soil%dwdx   => parts%dwdx
soil%pair_i => parts%pair_i
soil%pair_j => parts%pair_j
allocate(soil%countiac(maxn));    soil%countiac=0

! Fields variables
call allocate_particles_fields(soil)

soil%txx => txx; soil%tyy => tyy; soil%txy => txy
soil%wxy => txy

soil%material => SiO2

return
end subroutine

!-------------------------------------------
     subroutine allocate_particles(parts)
!-------------------------------------------
use m_particles
implicit none

type(particles) parts
integer dim,maxn,max_interaction

dim  = parts%dim
maxn = parts%maxn
max_interaction = parts%max_interaction 

if(.not.associated(parts%itype)) allocate(parts%itype(maxn))
if(.not.associated(parts%x))     allocate(parts%x(dim,maxn))
if(.not.associated(parts%vol))   allocate(parts%vol(maxn))
if(.not.associated(parts%mass))  allocate(parts%mass(maxn))
if(.not.associated(parts%hsml))  allocate(parts%hsml(maxn))

return
end subroutine

!---------------------------------------------------------
     subroutine allocate_particles_fields(parts)
!---------------------------------------------------------
! Fields variables
!---------------------------------------------------------
use m_particles
implicit none

type(particles) parts
integer dim,maxn

dim  = parts%dim
maxn = parts%maxn

allocate(parts%vx(dim,maxn));  parts%vx  = 0.d0
allocate(parts%rho(maxn));     parts%rho = 0.d0
allocate(parts%p(maxn));       parts%p   = 0.d0
allocate(parts%u(maxn));       parts%u   = 0.d0
allocate(parts%c(maxn));       parts%c   = 0.d0
allocate(parts%eta(maxn));     parts%eta = 0.d0 

! Old value
allocate(parts%v_min(dim,maxn));   parts%v_min   = 0.d0
allocate(parts%rho_min(maxn));     parts%rho_min = 0.d0
allocate(parts%u_min(maxn));       parts%u_min   = 0.d0

! Accelerations
allocate(parts%drho(maxn));    parts%drho= 0.d0  
allocate(parts%dvx(dim,maxn)); parts%dvx = 0.d0  
allocate(parts%du(maxn));      parts%du  = 0.d0 
allocate(parts%av(dim,maxn));  parts%av  = 0.d0

! Volume Fraction
allocate(parts%vof(maxn))
parts%vof = 0.d0

if(trim(parts%imaterial)=='water')then
   allocate(parts%dvof(maxn))
   parts%dvof = 0.d0
   allocate(parts%vof_min(maxn))
   parts%vof_min = 0.d0
endif

if(trim(parts%imaterial)=='soil')then
   allocate(parts%sxx(maxn), parts%syy(maxn), parts%sxy(maxn))
   parts%sxx = 0.d0; parts%sxy = 0.d0; parts%syy = 0.d0
   allocate(parts%sxx_min(maxn))
   allocate(parts%syy_min(maxn))
   allocate(parts%sxy_min(maxn))
   allocate(parts%p_min(maxn))
   allocate(parts%vcc(maxn))    
   allocate(parts%szz(maxn))    !!! Intel Fortran Compiler is shit!!!
   parts%sxx_min = 0.d0; parts%sxy_min = 0.d0; parts%syy_min = 0.d0
   parts%p_min = 0.d0
   parts%vcc = 0.d0
   allocate(parts%dsxx(maxn),parts%dsyy(maxn),parts%dsxy(maxn))
   parts%dsxx = 0.d0; parts%dsxy = 0.d0; parts%dsyy = 0.d0
   allocate(parts%dp(maxn))
   parts%dp(maxn) = 0.d0
   allocate(parts%fail(maxn)); parts%fail = 0

   allocate(parts%epsilon_p(maxn))
   parts%epsilon_p = 0.d0
endif

allocate(parts%drhodx(dim,maxn))
parts%drhodx = 0.d0

return
end subroutine
!---_------------------------
    subroutine close_files
!----_-----------------------
use declarations_sph

implicit none

close(f_xv)
close(f_state)
close(f_other)

return
end subroutine
!-----------------------------
    module declarations_sph
!-----------------------------
use m_particles
implicit none

! Logic unit of files

integer f_xv,f_state,f_other
integer xv_vp,state_vp,other_vp

! Files
character(len=32) results, res_water, res_soil

! Boundary conditions
double precision inlet_velocity

! Geometry object
type(geo) wasserjet
logical with_nozzle


! Particle size: large, small?
character(len=32) particle_size

logical single_phase
logical dry_soil

! Particle type : water, soil or mixture?
character(len=32) particle_type

type(material), target :: H2O, SiO2

! Particles 
type(particles), target :: parts, soil

! Working arrays
double precision, pointer, dimension(:) :: txx=>null(), tyy=>null(), txy=>null()

! Physical variables carried by the particles
!double precision, pointer, dimension(:)   ::  rho => null()
!double precision, pointer, dimension(:,:) ::   vx => null()
!double precision, pointer, dimension(:)   ::    p => null()
!double precision, pointer, dimension(:)   ::    c => null()
!double precision, pointer, dimension(:)   ::    t => null()
!double precision, pointer, dimension(:)   ::    u => null()
!double precision, pointer, dimension(:)   ::    s => null()
!double precision, pointer, dimension(:)   ::    e => null()
!double precision, pointer, dimension(:)   ::  eta => null()

! Temporal variables
!double precision, pointer, dimension(:)   ::  drho => null()
!double precision, pointer, dimension(:,:) ::   dvx => null()
!double precision, pointer, dimension(:)   ::    du => null()
!double precision, pointer, dimension(:,:) ::    av => null()

!double precision, pointer, dimension(:,:) :: indvxdt=>null()
!double precision, pointer, dimension(:,:) :: ardvxdt=>null()
!double precision, pointer, dimension(:,:) :: exdvxdt=>null()
!double precision, pointer, dimension(:)   ::  avdudt=>null()
!double precision, pointer, dimension(:)   ::  ahdudt=>null()

!type(array) indvxdt, ardvxdt, exdvxdt, indudt, avdudt, ahdudt

!Numerical paramters
double precision :: dt, time = 0.d0
integer :: maxtimestep = 0 , itimestep = 0

end module
      subroutine darcy_law(water, soil)

!--------------------------------------------------------------------------
!     Subroutine to calculate the external forces, e.g. gravitational forces.      
!     The forces from the interactions with boundary virtual particles 
!     are also calculated here as external forces.

!     here as the external force. 
!     ntotal  : Number of particles                                 [in]
!     mass    : Particle masses                                     [in]
!     x       : Coordinates of all particles                        [in]
!     pair_i : List of first partner of interaction pair            [in]
!     pair_j : List of second partner of interaction pair           [in]
!     itype   : type of particles                                   [in]
!     hsml   : Smoothing Length                                     [in]
!     dvxdt   : Acceleration with respect to x, y and z            [out] 

      use param
      use m_particles
      implicit none

      type(particles) water, soil
      double precision dx(dim), ks, ns, gw, cf, sp, rrw
      type(material), pointer :: h2o,sio2     
      integer i, j, k, d

      h2o => water%material
      sio2=>  soil%material

      gw = h2o%rho0*(-gravity); ns = sio2%porosity
      ks = sio2%permeability
      cf = gw*ns/ks
      !cf = 6.e6
       
      do  k=1,water%niac
          i = water%pair_i(k)
          j = water%pair_j(k)  
          rrw = water%w(k)/(water%rho(i)*soil%rho(j))

! For staturated soil
          cf = water%vof(i)*water%rho(i)*(-gravity)/ks

          do d=1,dim
             sp = cf*(water%vx(d,i)-soil%vx(d,j))*rrw
             water%dvx(d,i) = water%dvx(d,i) - soil%mass(j)*sp
             soil%dvx(d,j)  = soil%dvx(d,j) + water%mass(i)*sp   
          enddo
      enddo

      return
      end subroutine 

!-----------------------------------------------------
      subroutine pore_water_pressure(water,soil)
!-----------------------------------------------------
      use param
      use m_particles
      implicit none
      
      type(particles) water, soil
      double precision mprr
      integer i, j, k, d
      
      do k = 1, water%niac
         i = water%pair_i(k)   ! water
         j = water%pair_j(k)   ! soil
         mprr = water%mass(i)*water%p(i)/(water%rho(i)*soil%rho(j))
!         mprr = water%mass(i)*(water%p(i)+soil%p(j))/       &      Bui2014
!                (water%rho(i)*soil%rho(j))
         do d = 1, dim
            soil%dvx(d,j) = soil%dvx(d,j) + mprr*water%dwdx(d,k)  &  !+
                            *soil%vof(j)  
         enddo

! saturated soil
 
         do d = 1, dim
            water%dvx(d,i) = water%dvx(d,i) -                     & 
            soil%mass(j)*water%p(i)*soil%vof(j)*water%dwdx(d,k)/  &
            (water%rho(i)*soil%rho(j)) 
         enddo
      enddo

      return
      end subroutine       

!-------------------------------------------------------------
      subroutine volume_fraction_water(water, soil)
!-------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) water, soil
      integer i,j,k,d, ntotal
      type(material), pointer :: sio2
      !double precision aaa(maxn)

      sio2 => soil%material
      ntotal = water%ntotal+water%nvirt

      !aaa(1:ntotal) = water%vof(1:ntotal)

      water%vof = 0.d0
      do k = 1, water%niac
         i = water%pair_i(k)
         j = water%pair_j(k)
         water%vof(i) = water%vof(i)+soil%mass(j)*water%w(k)
      enddo

      do k = 1, water%ntotal+water%nvirt
         water%vof(k) = 1.d0 - water%vof(k)/sio2%rho0
      enddo

      !write(*,*) aaa(1:ntotal)-water%vof(1:ntotal)
      !pause 'asdfadfauieyqioweru'

      return
      end subroutine 

!-------------------------------------------------------------
      subroutine volume_fraction_water2(water, soil)
!-------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) water, soil
      integer i,j,k,d, ntotal
      type(material), pointer :: sio2
      double precision dvx(dim),tmp

      sio2 => soil%material
      ntotal = water%ntotal+water%nvirt

!      water%dvof = 0.d0

      do k = 1, water%niac
         i = water%pair_i(k)
         j = water%pair_j(k)
         do d = 1, dim
            dvx(d) = water%vx(d,i)-soil%vx(d,j)
         enddo 
         tmp = dvx(1)*water%dwdx(1,k)+dvx(2)*water%dwdx(2,k)
         water%dvof(i) = water%dvof(i)-soil%mass(j)*tmp/sio2%rho0
      enddo

      return
      end subroutine 

!--------------------------------------------------------------------
      subroutine volume_fraction_soil(parts)
!--------------------------------------------------------------------
      use param
      use m_particles
      implicit none

      type(particles) parts
      integer i,j,k, ntotal
      type(material), pointer :: sio2

      sio2 => parts%material
      ntotal = parts%ntotal + parts%nvirt

      do i = 1, ntotal
         parts%vof(i) = parts%rho(i)/sio2%rho0
      enddo

      return
      end subroutine


!---------------------------
    module m_particles
!---------------------------
use constants, ex_pi=>pi
implicit none

! Configuration of the water-jet problem; Problem specific
type geo

! size of each dimension
  double precision dl,dr,dh,ds,dj,D,L,H,immerse
! descrete intervals
  integer  mdl,mdr,mdh,mds,mdj,mD,mL,mH
  contains
    procedure :: set => set_geo_sub

end type

type block
     real(dp) xl, yl
     integer  m,  n
     real(dp) dx, dy
     real(dp), pointer, dimension(:) :: x,y
   contains
     procedure :: set => set_block_sub
     procedure :: cell_center => get_cell_center_sub
end type

type particle
   integer itype
   real(dp) x, y, vol, hsml, mass
   contains
      procedure :: copy => copy_particle_sub
end type

type enumerator
   integer :: inside = 0, inlet = 1, boundary = 2
end type

type tensor
   real(dp) xx,xy,xz,yy,yz,zz
end type

type material

! For water

   real(dp) rho0,b,gamma,c,viscosity

! For soil

   real(dp) k,porosity,permeability,G,E,niu,cohesion,phi

end type


type array
   real(dp), pointer, dimension(:)   :: r  => null()
   real(dp), pointer, dimension(:,:) :: rr => null()
end type

! Particles in SPH method
type particles

   integer :: dim   = 0
   integer :: maxn  = 0
   integer :: niac  = 0
   integer :: max_interaction = 0
   integer :: ntotal = 0, nvirt = 0

   character(len=32) :: imaterial
   class(*), pointer :: material => null()

! Particle fundamental data
   integer,  pointer, dimension(:)   :: itype=> null()
   real(dp), pointer, dimension(:,:) :: x    => null()
   real(dp), pointer, dimension(:)   :: vol  => null()
   real(dp), pointer, dimension(:)   :: mass => null()
   real(dp), pointer, dimension(:)   :: hsml => null()
   integer,  pointer, dimension(:)   :: zone => null()

! Volume of Fraction
   real(dp), pointer, dimension(:)   :: vof  => null()
   real(dp), pointer, dimension(:)   :: dvof  => null()
   real(dp), pointer, dimension(:)   :: vof_min  => null()

! Field variables
   real(dp), pointer, dimension(:)   :: rho  => null()
   real(dp), pointer, dimension(:,:) :: vx   => null()   
   real(dp), pointer, dimension(:)   :: p    => null()
   real(dp), pointer, dimension(:)   :: eta  => null()   
   real(dp), pointer, dimension(:)   :: c    => null()   
   real(dp), pointer, dimension(:)   :: u    => null()

! Stress tensor 
   !type(tensor), pointer, dimension(:)   :: st   => null() 
   real(dp), pointer, dimension(:) :: sxx => null(), syy => null()
   real(dp), pointer, dimension(:) :: szz => null(), sxy => null()
   real(dp), pointer, dimension(:) :: sxz => null(), syz => null()
 
! Shear strain rate 
   real(dp), pointer, dimension(:) :: txx => null(), tyy => null()
   real(dp), pointer, dimension(:) :: tzz => null(), txy => null()
   real(dp), pointer, dimension(:) :: txz => null(), tyz => null()
! Bulk strain rate, i.e. divergency of velocity
   real(dp), pointer, dimension(:) :: vcc => null()

! Accumulative deviatoric strain
   real(dp), pointer, dimension(:) :: epsilon_p => null()

! Rotation tensor
   real(dp), pointer, dimension(:) :: wxy => null()

! Old values
   real(dp), pointer, dimension(:)   :: rho_min => null()
   real(dp), pointer, dimension(:,:) :: v_min   => null()
   real(dp), pointer, dimension(:)   :: u_min   => null()
   real(dp), pointer, dimension(:)   :: p_min   => null()
   real(dp), pointer, dimension(:) :: sxx_min => null(), syy_min => null()
   real(dp), pointer, dimension(:) :: szz_min => null(), sxy_min => null()
   real(dp), pointer, dimension(:) :: sxz_min => null(), syz_min => null()

! Acceleration
   real(dp), pointer, dimension(:)     :: drho => null()
   real(dp), pointer, dimension(:,:)   :: dvx  => null()
   real(dp), pointer, dimension(:)     :: du   => null()
   real(dp), pointer, dimension(:)     :: dp   => null()
   real(dp), pointer, dimension(:,:)   :: av   => null()
!   type(tensor), pointer, dimension(:) :: dst  => null()
   real(dp), pointer, dimension(:) :: dsxx => null(), dsyy => null()
   real(dp), pointer, dimension(:) :: dszz => null(), dsxy => null()
   real(dp), pointer, dimension(:) :: dsxz => null(), dsyz => null()

! Density gradient
   real(dp), pointer, dimension(:,:)     :: drhodx => null()

! For soil failure
   integer :: nfail = 0
   integer, pointer, dimension(:) :: fail => null()

! Kernel and its derivative
   real(dp), pointer, dimension(:)   :: w    => null()
   real(dp), pointer, dimension(:,:) :: dwdx => null()

! Particle interaction pair
   integer :: maxp = 0, minp = 0
   integer :: maxiac = 0, miniac = 0
   integer :: sumiac = 0, noiac  = 0
   integer, pointer, dimension(:)  :: pair_i => null()
   integer, pointer, dimension(:)  :: pair_j => null()
   integer, pointer, dimension(:)  :: countiac=>null()

! Boundry particles defined as type particles
   type(particles), pointer :: bor

! Multiphase flow
!   type(particles), pointer :: water => null(), soil => null()

   integer itimestep

   contains

       procedure :: write_particles
       procedure :: write_component 
       procedure :: append_virtual_particles
       procedure :: depend_virtual_particles
       procedure :: interaction_statistics
       procedure :: minimum_time_step
 
end type 

interface write_field
   module procedure :: write_scalar_field
   module procedure :: write_vector2d_field
end interface

!interface p2m
!   module procedure :: point_to_water
!end interface

!=======
contains
!=======

!---------------------------------------------------------------------------------
   subroutine set_geo_sub(this,dl,dr,dh,ds,dj,D,L,H,immerse,       &
                              mdl,mdr,mdh,mds,mdj,mD,mL,mH)
!---------------------------------------------------------------------------------
   implicit none
   class(geo) this
   real(dp), optional :: dl,dr,dh,ds,dj,D,L,H,immerse
   integer,  optional :: mdl,mdr,mdh,mds,mdj,mD,mL,mH

   if(present(dl)) this%dl = dl  
   if(present(dr)) this%dr = dr  
   if(present(dh)) this%dh = dh  
   if(present(ds)) this%ds = ds  
   if(present(dj)) this%dj = dj  
   if(present(D)) this%D = D  
   if(present(L)) this%L = L  
   if(present(H)) this%H = H  
   if(present(immerse)) this%immerse = immerse

   if(present(mdl)) this%mdl = mdl  
   if(present(mdr)) this%mdr = mdr  
   if(present(mdh)) this%mdh = mdh  
   if(present(mds)) this%mds = mds  
   if(present(mdj)) this%mdj = mdj  
   if(present(mD)) this%mD = mD  
   if(present(mL)) this%mL = mL  
   if(present(mH)) this%mH = mH  
  
   return
   end subroutine

!--------------------------------------------
   subroutine set_block_sub(this,xl,yl,m,n)
!--------------------------------------------
implicit none
class(block) this
real(dp),optional :: xl,yl
integer, optional :: m, n

if(present(xl)) this%xl = xl
if(present(yl)) this%yl = yl
if(present(m))  this%m  = m
if(present(n))  this%n  = n

return
end subroutine

!------------------------------------------------
   subroutine get_cell_center_sub(this)
!------------------------------------------------
implicit none
class(block) this
integer i,j,k

this%dx = this%xl/this%m
this%dy = this%yl/this%n

k = 0
do i = 1, this%m
   do j = 1, this%n
      k = k + 1
      this%x(k) = (i-1)*this%dx + this%dx/2.
      this%y(k) = (j-1)*this%dy + this%dy/2.
   enddo
enddo

return
end subroutine

!-------------------------------------------
   subroutine copy_particle_sub(this,that)
!-------------------------------------------
implicit none
class(particle) this
class(particle)  that

this%x = that%x

return
end subroutine

!----------------------------------------
   subroutine write_particles(this) 
!----------------------------------------
implicit none
class(particles) this
integer i

write(*,*) 'Real particles:'
write(*,*) 'Num.  itype  x   y   vol  hsml'
do i = 1, this%ntotal
   write(*,*) i,  this%itype(i), this%x(1,i), this%x(2,i), this%vol(i), this%hsml(i) 
end do

write(*,*) 'Virtual particles:'
write(*,*) 'Num.  itype  x   y   vol  hsml'
do i = this%ntotal+1, this%ntotal+this%nvirt
   write(*,*) i,  this%itype(i), this%x(1,i), this%x(2,i), this%vol(i), this%hsml(i) 
end do

return
end subroutine

!---------------------------------------------
   subroutine write_component(this,vars) 
!---------------------------------------------
implicit none
class(particles) this
character(len=*) vars
integer ntotal, nvirt, i

ntotal = this%ntotal
nvirt  = this%nvirt

select case (trim(vars))
   case ('x')
      write(*,*) 'Particle position:'
      do i = 1, ntotal+nvirt
         write(*,*) i,this%x(1,i),this%x(2,i)
      enddo
   case ('mass')
      write(*,*) 'Particle mass:'
      do i = 1, ntotal+nvirt
         write(*,*) i, this%mass(i)
      enddo
   case('w')
      write(*,*) 'Kernels:'
      write(*,*) (i,this%w(i), i = 1, this%niac)
   case('dwdx')
      write(*,*) 'Derivatives of Kernels:'
      write(*,*) (i,this%dwdx(1,i),this%dwdx(2,i),i = 1, this%niac)
   case ('pairs')
      write(*,*) 'Interaction pairs:'
      write(*,*) (i, this%pair_i(i), this%pair_j(i),'|',i=1,this%niac)
   case default
      write(*,*) 'Write this compoent is not implemented yet!'
end select

return
end subroutine

!-------------------------------------------------
     subroutine interaction_statistics(parts)
!-------------------------------------------------
implicit none
class(particles) parts

          print *,' >> Statistics: interactions per particle:'
          print *,'**** Particle:',parts%maxp,                 &
                  ' maximal interactions:', parts%maxiac
          print *,'**** Particle:',parts%minp,                 &
                  ' minimal interactions:', parts%miniac
          print *,'**** Average :',real(parts%sumiac)/         &
                             real(parts%ntotal+parts%nvirt)
          print *,'**** Total pairs : ',parts%niac
          print *,'**** Particles with no interactions:',parts%noiac

return
end subroutine

!-------------------------------------------------
     subroutine minimum_time_step(parts)
!-------------------------------------------------
implicit none
class(particles) parts

type(material), pointer :: mat
integer ntotal
double precision c, miu 
double precision mint1, mint21, mint22, mint3

ntotal = parts%ntotal

mat => parts%material
c   = mat%c
miu = mat%viscosity/mat%rho0

! CFL condition
mint1 = 0.25*minval(parts%hsml(1:ntotal)/c)
! Acceleration 
mint21 = 0.25*minval(sqrt(parts%hsml(1:ntotal)/parts%dvx(1,1:ntotal)))
mint22 = 0.25*minval(sqrt(parts%hsml(1:ntotal)/parts%dvx(2,1:ntotal)))
! Viscous diffustion time
mint3 = 0.125*minval(parts%hsml(1:ntotal)**2/miu)

write(*,*) 'Minimum time step is: '
write(*,*) ' mint1 = ', mint1
write(*,*) ' mint21 = ', mint21, ' mint22 = ', mint22
write(*,*) ' mint3 = ', mint3

return
end subroutine

!-------------------------------------------------
     subroutine particle_monitor(this)
!-------------------------------------------------
implicit none
class(particles) this

!          write(*,*)
!          write(*,*) '**** Information for particle ****', 
!     &        		moni_particle         
!          write(*,101)'internal a ','artifical a=',
!     &         		'external a ','total a '   
!          write(*,100)indvxdt%rr(1,moni_particle),
!     &                ardvxdt%rr(1,moni_particle),
!     &                exdvxdt%rr(1,moni_particle),
!     &                parts%dvx(1,moni_particle)          
!      endif
!101   format(1x,4(2x,a12))      
!100   format(1x,4(2x,e13.6))      

return
end subroutine

!-------------------------------------------------
   subroutine write_scalar_field(field,parts)
!-------------------------------------------------
implicit none
double precision, dimension(:) :: field
type(particles) parts
integer i,ntotal

ntotal = parts%ntotal+parts%nvirt

write(*,*) (i, field(i),i=1,ntotal)

return
end subroutine

!-------------------------------------------------
   subroutine write_vector2d_field(field,parts)
!-------------------------------------------------
implicit none
double precision, dimension(:,:) :: field
type(particles) parts
integer i,ntotal

ntotal = parts%ntotal+parts%nvirt

write(*,*) (i, field(1,i),field(2,i),i=1,ntotal)

return
end subroutine

!---------------------------------------------------
    subroutine append_virtual_particles(this)
!---------------------------------------------------
implicit none
class(particles) this

type(particles), pointer :: bor
integer ntotal, i, k

bor    =>this%bor

! First, assembly all the real particles

!ntotal = this%ntotal
!k = 0 
!do i = 1, bor%ntotal
!   if(bor%itype(i)<0) cycle   ! real particles
!   k = k + 1
!   this%x(:,ntotal+k)  = bor%x(:,i)
!   this%hsml(ntotal+k) = bor%hsml(i)
!   this%vol(ntotal+k)  = bor%vol(i)
!   this%itype(ntotal+k)= bor%itype(i)
!   this%mass(ntotal+k) = bor%mass(i)
!enddo
!this%ntotal = this%ntotal + k

! Then assembly all the virtual particles

ntotal = this%ntotal
k = 0
do i = 1, bor%ntotal
   if(bor%itype(i)>0) cycle  ! virtual particles
   k = k + 1
   this%x(:,ntotal+k)  = bor%x(:,i)
   this%hsml(ntotal+k) = bor%hsml(i)
   this%itype(ntotal+k)= bor%itype(i)
   this%vol(ntotal+k)  = bor%vol(i)
   this%mass(ntotal+k) = bor%mass(i)
enddo
this%nvirt = k
!write(*,*) 'Appended virtual particle number: ', this%nvirt

return
end subroutine

!---------------------------------------------------
    subroutine depend_virtual_particles(this)
!---------------------------------------------------
implicit none
class(particles) this

!type(particles), pointer :: bor
!integer ntotal,nvirt, i,j,k

!ntotal = this%ntotal
!nvirt  = this%nvirt

!bor => this%bor

!k = 0
!do i = ntotal+1, ntotal+nvirt

!!   if(this%zone(i)==?) cycle      ! Symetery boundary virtural particles is skipped! 

!   j = i - ntotal
!   k = k + 1
!   bor%x(:,j)  = this%x(:,i)
!   bor%hsml(j) = this%hsml(i)
!   bor%vol(j)  = this%vol(i)
!   bor%zone(j) = this%zone(i)
!enddo
!this%nbor = k 

return
end subroutine

!-------------------------------------------------------
!    subroutine point_to_water(p, property)
!-------------------------------------------------------
!implicit none
!class(*), target :: property
!type(h2O), pointer :: p

!select type (property)
!   type is (h2O)
!      p => property
!end select
!
!return
!end subroutine

end module


!---------------------------
    subroutine open_files
!---------------------------
!use declarations
use declarations_sph
implicit none

call get_unit(f_xv)
open(f_xv,file="../f_xv.dat")
!open(f_xv,file=trim(results))
call get_unit(f_state)
open(f_state,file="../f_state.dat")
!open(f_state,file=trim(res_soil))
call get_unit(f_other)
open(f_other,file="../f_other.dat") 

call get_unit(xv_vp)
open(xv_vp,file="../xv_vp.dat")
call get_unit(state_vp)
open(state_vp,file="../state_vp.dat")
call get_unit(other_vp)
open(other_vp,file="../other_vp.dat")

return
end subroutine
!--------------------------------
       subroutine set_bc
!--------------------------------
use declarations_sph
implicit none



return
end subroutine
   subroutine time_elapsed(s)

!===============================================================================
!   The standard Fortran 90 routine RTC is used to calculate the elapsed CPU
!===============================================================================

    use ifport
    implicit none

    integer, parameter :: output = 6
    real(8) :: s

   s = rtc()

   end subroutine time_elapsed
   subroutine time_print

!===============================================================================
!   TIME_PRINT                     Print out the current date and time.
!
!   Notes:
!
!   The standard Fortran 90 routine DATE_AND_TIME is used to get the current
!   date and time strings.
!
!===============================================================================

    implicit none
    integer, parameter :: output = 6

   ! . local scalars.
   character ( len =  8 ) :: datstr
   character ( len = 10 ) :: timstr

   ! . Get the current date and time.
   call date_and_time ( datstr, timstr )

   ! . Write out the date and time.
   write ( output, "(/A)"  ) "                  Date = " // datstr(7:8) // "/" // &
                                          datstr(5:6) // "/" // &
                                          datstr(1:4)
   write ( output, "(A)"   ) "                  Time = " // timstr(1:2) // ":" // &
                                          timstr(3:4) // ":" // &
                                          timstr(5:10)
   write ( output, *)

   end subroutine time_print

